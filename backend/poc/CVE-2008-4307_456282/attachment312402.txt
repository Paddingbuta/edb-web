#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sched.h>
#include <linux/unistd.h>
#include <fcntl.h>
#include <pthread.h>

/* pid_t gettid(void) */
_syscall0(pid_t,gettid);

volatile int fd = -1;

/**
 * arg - unused
 */
void *do_lock(void *arg)
{
	struct flock fl;

	fprintf(stderr, "pid %d thread %d in do_lock\n", getpid(), gettid());

	fl.l_type = F_WRLCK;
	fl.l_whence = SEEK_SET;
	fl.l_start = 0; /* may as well lock it all */
	fl.l_len = 0;

	fprintf(stderr, "pid %d thread %d  locking\n", getpid(), gettid());
	if(fcntl(fd, F_SETLKW, &fl) == -1) {
		perror("fcntl");
		exit(1);
	}
	fprintf(stderr, "pid %d thread %d  LOCKED\n", getpid(), gettid());
	return NULL;
}

/**
 * Attempt to lock a file in one thread while terminating
 * the process from another.
 *
 * argv[1] - file system path to lock
 */
int main(int argc, char **argv)
{
	pthread_t locker;

	if (argc < 2) {
		fprintf(stderr, "usage:\n%s <path>\n", argv[0]);
		exit(1);
	}

	fd = open(argv[1], O_RDWR);
	if (fd < 0) {
		perror("open");
		exit(1);
	}

	fprintf(stderr, "pid %d main launching thread\n", getpid());
	pthread_create(&locker, NULL, do_lock, argv[1]);

	sched_yield();
	close(fd);
	pause();
	return 0;
}
