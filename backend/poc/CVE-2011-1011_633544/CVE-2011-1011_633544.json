{
    "bugid": "633544",
    "cveid": [
        "CVE-2011-1011"
    ],
    "summary": "CVE-2011-1011 policycoreutils: insecure temporary directory handling in seunshare",
    "alias": "CVE-2011-1011",
    "product": "Security Response",
    "hardware": "All",
    "os": "Linux",
    "url": "",
    "reported_date": "2010-09-13 22:13 UTC byVincent Danen",
    "attachment": [
        "https://bugzilla-attachments.redhat.com/attachment.cgi?id=482691"
    ],
    "comment": [
        "Tavis Ormandy reported that seunshare, part of policycoreutils, was shipped setuid root and failed to enforce proper permissions on an alternate temporary directory mounted as /tmp.  This could potentially lead to privilege escalation in certain privileged applications that assume /tmp to be sticky and root-owned.\n\nAcknowledgements:\n\nRed Hat would like to thank Tavis Ormandy for reporting this issue.",
        "Just to summarize the situation as I see it here.  This is believed to be fixed now in the recent policycoreutils versions, such as policycoreutils-2.0.83-28.fc13, via this patch:http://pkgs.fedoraproject.org/gitweb/?p=policycoreutils.git;a=blob;f=policycoreutils-rhat.patch;h=d4db5bc06027de23d12a4b3f18fa6f9b1517df27;hb=HEAD#l2197It extends seunshare_mount() to mount with nosuid/nodev/noexec (this does not seem to make a difference for the problem reported by Tavis) and forces sticky bit on the /tmp directory upon mount.  However, there does not seem to be any change to prevent user from removing sticky bit right after it's added, and the sticky bit does not prevent non-privileged user from removing file from a directory he or she owns.\n\nAFAIK, Tavis proposed two possible fixes:\n- restrict seunshare to a dedicated group\n- create temporary directory in some safe location and with safe ownership and permissions (which include sticky bit)\n\nNote: Allowing user to specify arbitrary directory to bind-mount can also allow bypassing certain filesystem permissions restrictions (getting access to the directory that is not normally accessible to the user), but verify_mount() check makes this bypass fairly restricted and uninteresting.",
        "I guess the only solution to this would be to force the tmp directory to be either a tmpfs directory or on /tmp it self.  Would that satisfy the problem?",
        "Wouldn't the use of /tmp itself beat the purpose of seunshare-ing /tmp?  It also can not be done with current seunshare due to the verify_mount() ownership check:\n\n$ seunshare -t /tmp -h $HOME /bin/bash\nInvalid mount point, reporting to administrator: Operation not permitted\n\ntmpfs should provide an easy way to have a run-specific directory that can be trashed as the end of the session easily, at the cost of memory use.  What is more important for intended sandbox use - have concurrently running instances not share the same directory as /tmp, or have /tmp content persist across sandbox runs?",
        "No I was talking about seunshare enforcing that the user say\n\nseunshare -t /tmp/mytmp -h $HOME/bin/bash\n\nMeaning the user has to create the directory within /tmp to mount over /tmp.",
        "I think we should add tmpfs support, but I can see a use case for users having persistance.  (Of course this could be argued against.)",
        "(In reply tocomment #12)> No I was talking about seunshare enforcing that the user say\n> \n> seunshare -t /tmp/mytmp -h $HOME/bin/bash\n> \n> Meaning the user has to create the directory within /tmp to mount over /tmp.You do not want mytmp to be user-owned, otherwise your new /tmp will be user-owned.",
        "So Tomas you think the only valid/safe thing to do is to use tmpfs?",
        "Not really.  The approach Tavis proposed - to make seunshare create root-owned directory with safe permissions - should work as well.\n\nJust a quick summary of the options, with some pros and cons listed:\n\n- /var/sandbox/tmp-$USER, root:$USER, 1770\n  - pro: directory to store per-user tmp directories is not world-writeable,\n    hence it's easier to create per-user directories safely\n  - pro: persistence\n  - con: same directory shared between concurrent sandbox runs\n  - con: another user-writeable directory (in addition to expected things as\n    /home, /tmp, /var/tmp)\n\n- the above can be changed to use existing temporary directory instead of /var/sandbox, which avoids unexpected user-writeable directory, but needs more sanity checks, other pros/cons are similar to the above; this can be \"DoS\"-ed (one unprivileged user pre-created tmp-$USER for some other user (when using /tmp/sandbox-tmp-$USER) or all users (when using /tmp/sandbox/tmp-$USER))\n\n- per-run temporary directory similar to current /tmp/.sandboxXXXXXXXX,\n  root:$USER, 1770 permissions\n  - pro: new per-run temporary directory\n  - pro: possible \"keep after run\" persistence\n  - con: more work to remove it safely after run\n\n- tmpfs use should be the variant of the previous, without \"keep after run\" persistence, but with easier clean-up\n\nNeither of these preserves the flexibility of the current version, so we should pick the approach that is the most aligned with sandbox's intended use case.",
        "Dan, does any of the above option looks preferred wrt existing seunshare uses?",
        "I looked into using tmpfs rather then a directory the user controls, but that would break one of the use cases.   I have firefox setup to execute sandbox everytime it downloads a pdf or .doc file, but if it is setup to download to /tmp, this would break using tmpfs.\n\nsandbox creates NEWHOME and NEWTMP and then copies all files in the command path to those directories.\n\nsandbox -X evince /tmp/mydoc.pdf \n\nCopies /tmp/mydoc.pdf to NEWTMP and then mounts NEWTMP over /tmp\n\nWhat about if we chown root:root NEWTMP and then mount.  \n\nchown UID:UID NEWTMP \n\nwhen done.",
        "(In reply tocomment #18)> What about if we chown root:root NEWTMP and then mount.  \n> \n> chown UID:UID NEWTMP \n> \n> when done.Does \"when done\" refer to the end of seunshare run?  That may only work if there's a reliable way to delay that ownership restore (hence seunshare exit) until after all processes that may have been started from the process executed by seunshare exited.  seunshare currently does not ensure that, it exits once its child process terminates.  So the plain chmod back after waitpid won't help.\n\nI see there's no clean up code in the current seunshare version at all.  Is it not needed to clean up the private mounts?  Does kernel do that automatically once no process that can see them exists?",
        "Yes.  Umount and destruction of the share happens automatically.  Not sure if there is a way for seunshare to know if all of the processes are exited.",
        "One observation is that you can cd to /proc/<seunshare child pid>/root and check ./tmp there to see if it still has NEWTMP mounted.  Running on two terminals (noted as [1] and [2] below):\n\n[1] ~ $ ls -lid /tmp /tmp/test-sandbox\n65025 drwxrwxrwt. 32 root root 12288 Nov 24 14:41 /tmp\n97564 drwxr-xr-x.  2 test test  4096 Nov 24 14:41 /tmp/test-sandbox\n\n[1] ~ $ seunshare -v -t /tmp/test-sandbox -h $HOME /bin/bash\nMount /home/test on /home/test\nMount /tmp/test-sandbox on /tmp\n\n[1-seunshare] ~ $ echo $$\n5940\n\n[2] ~ $ cd /proc/5940/root/\n\n[2] /proc/5940/root $ ls -lid ./tmp/\n97564 drwxr-xr-t. 2 test test 4096 Nov 24 14:41 ./tmp/\n\n[1-seunshare] ~ $ cat blah.sh \n#!/bin/sh\necho \"Sleeping for $1 sec\"\nsleep $1\necho \"Done with $1 sec sleep\"\n\n[1-seunshare] ~ $ ./blah.sh 60 & ./blah.sh 90 & ./blah.sh 120 &\n[1] 6000\n[2] 6001\n[3] 6002\n\n[1-seunshare] ~ $ exit               \n\n[1] ~ $ ls -lid /proc/5940/root/tmp\nls: cannot access /proc/5940/root/tmp: No such file or directory\n\nwhile [2] still sees it's root:\n\n[2] /proc/5940/root $ ls -lid ./tmp/\n97564 drwxr-xr-t. 2 test test 4096 Nov 24 14:41 ./tmp/\n\nOnce all processes are done:\n\n[2] /proc/5940/root $ ls -lid ./tmp/\n65025 drwxrwxrwt. 32 root root 12288 Nov 24 14:52 ./tmp/\n\n\nStill chowning arbitrary user directory to root may prove problematic.",
        "Interesting, not sure if this is a problem or not.  Sandbox sends a signal to all of its subprocess to try to get them to exit.\n\nThe major sticking point then is trying to figure a way to update the contents of /tmp with files if it was a temporary file system.\n\nOne potential solution would be to create the tmp directory within the $HOME and then cp the contents over the tmpfs once it is created.",
        "Or only allow certain path to be used as NEWTMP, such as /var/tmp/<something>?",
        "How does that help?",
        "If using the chowning approach (chown to root:user at the beginning of the seunshare run and chown back once all child processes exited), this will limit which directories can get their ownership changed.  Also limiting where stale / left-over directories can be if seunshare is terminated before it can chown directory back.",
        "is there any update on this issue, did you make a decision? (the solution I prefer is forcing the /tmp directory to be /var/sandbox/tmp-$USER root:root and 1777, and making /var/sandbox 700 root:root, I think this will work?)\n\nI would consider this bug fairly urgent, I admit I dont have a working exploit to turn this into a root shell, but a quick search of suid binaries available shows that at least ksu assumes /tmp is sticky.\n\nRight now an unprivileged user can destroy a system like this:\n\n$ seunshare -v -t /tmp/seunshare/ -h /tmp/seunshare/ -- `which ksu` root\nMount /tmp/seunshare/ on /home/taviso\nMount /tmp/seunshare/ on /tmp\nWARNING: Your password may be exposed if you enter it here and are logged \n         in remotely using an unsecure (non-encrypted) channel. \nKerberos password for root: : \n[1]+  Stopped                 seunshare -v -t /tmp/seunshare/ -h /tmp/seunshare/ -- `which ksu` root\n$ ls -l /tmp/seunshare/\ntotal 4.0K\n-rw-------. 1 root taviso 35 Feb 18 23:21 krb5cc_0.1\n$ rm -f /tmp/seunshare/krb5cc_0.1 \n$ ln /etc/passwd /tmp/seunshare/krb5cc_0.1\n$ fg\nseunshare -v -t /tmp/seunshare/ -h /tmp/seunshare/ -- `which ksu` root\n\nksu: Cannot read password while reading password for 'root'\n\nAuthentication failed.\n\n...and /etc/passwd just got nuked. Do you mind if I publish it so that administrators can remove seunshare if they're concerned about privilege escalation?\n\nIf I don't receive a response by Monday, I'll assume you don't mind.",
        "Dan, which of the current use cases are broken or negatively impacted by the proposed single NEWTMP for all seunchare runs approach?  Some pros/cons mentioned above.  I should probably add some issues with the first run, when user-specific sandbox-tmp directory has not been created yet.",
        "Tavis, how about we just go with removing -t PATH and just using -t, which will mount /dev/shm as 1777 root:root.",
        "sandbox -X evince /tmp/download.pdf\n\nNeeds to work.\n\nSo the way this works now is, sandbox command creates the tmpdir, and then copies the content into it, then seunshare mounts the tmpdir over /tmp/\n\nThis will not work on tmpfs since the tmpdir will not exist until after seunshare executes.  \n\nI could change the code to specify a tmpdir and have seunshare create its own tmpdir or tmpfs and copy the files from the local tmpdir into the tmpfs.\n\nWould this satisfy the needs.",
        "Yes, that sounds okay to me so long as seunshare creates it.",
        "Tavis, it is a little more difficult, but I have tried to recreate the vulnerabilty and have failed.  Are you saying you ksu without the root password and desctroyed the /etc/passwd file or are you saying your ksu was successful and destroyed the file?",
        "Yes, ksu without the password destroys the file.",
        "I confirm that ksu steps above work on EL6 with default krb5 config.",
        "Tomas, I'd like to publish a warning about this, would you prefer I wait? (I don't mind waiting if you guys are planning to work on this quickly). However if not much progress has been made since September, I think it's fairer to administrators to publish a warning asap.\n\nEven if the worst (that I can demonstrate) is destroying a system, I think it's a reasonable assumption that there is a configuration/package/customer software that relies on the stickyness of /tmp (perfectly reasonably) to prevent arbitrary code execution.\n\nTavis.",
        "Well, I waited an extra day because of the bank holiday in america, but there have been no objections, so I'm sending an advisory now.",
        "Hey Tavis, thanks.http://lists.grok.org.uk/pipermail/full-disclosure/2011-February/079490.html",
        "Createdattachment 480587[details]Rewrote seunshare.c to create tmpfs /tmp and label it correctly.\n\nThe program then copies the original /tmp files into the tmpfs.\n\nOne restriction on this version is that neither the home or tmp directories can actually be in /tmp.",
        "Maybe i'm reading it wrong, but you're running system() with euid=0?\n\nIf so, there is a command injection by specifying a temporary directory called `id` or something like that, as well as problems with inheriting an untrusted environment.",
        "Tavis, I think the getfilecon() would have failed on a command injection. \n\nHowever, I think if you go this way, you want to validate that its a directory but you might be subject to a TOCTOU race. You might need to hand copy all files using the openat, mkdirat, fchmodat, fchownat syscalls.\n\nUnless I am missing something, the current patch might allow concurrent use in which case the user will be consuming system memory with the tmpfs.\n\nAlso, if you have a malicious app that forks and calls setsid and tries to escape, will it be left holding resources when seunshare dies?",
        "Steve: Why do you say that? `id` is a valid filename. I tested it, and it works.\n\nRegardless, running system() with euid != uid is hard to get right due to the untrusted environment.",
        "bash tries to drop privs in such case.  It does not check set[ug]id return value, it seems, but the easy nproc limit trick to make that fail is not applicable here.\n\nseunshare also got setfsuid call (too) early on, so it always fails on setfilecon(\"/tmp\").",
        "(In reply tocomment #40)> Also, if you have a malicious app that forks and calls setsid and tries to\n> escape, will it be left holding resources when seunshare dies?Yes.  They are also not well visible, as those private mounts don't show up in /proc/mounts.",
        "Createdattachment 480816[details]Here is a patch to the original seunshare to fix some of the problems found\n\nOne it now opens the mntdir and uses the fd to checking access.\ntmpdir is no longer an option for seunshare, if there is a subdir of the homedir named .sandboxtmp, then the contents of this directory will be copied to the /tmp directory after dropping capabilities.\n\nMoved the setfsuid call lower in the program.  While still not checking if it was successful, code below will fail on NFS homedirs if it was not successful.\n\nI also moved the large cgroups code block into its own function.\n\nI am setting the context on the /tmp directory based on the context of the homedir after it was mounted.  \n\nI also added a mount bind of /tmp on /var/tmp to allow the sandbox to write to /tmp and /var/tmp.",
        "Createdattachment 480817[details]Updated code",
        "I looked at the code, there's a TOCTOU with verify mount I think.\n\nYou do verify_mount(); then mount(); so you can do something like:\n\n# Create a legal mount directory\nmkdir /home/foo/seunshare/bin\n\n# give it to seunshare\nseunshare -h ~/seunshare/bin &\n\n# between the verify() and the mount(), do:\n$ rm -rf ~/seunshare; ln -s / ~/seunshare\n\nIf you win the TOCTOU, you get mount(\"/home/foo/seunshare/bin\", \"/home\"), which is mount(\"/bin\", \"/home\"). I'm not sure if that can be exploited, but it's worrying.",
        "We also verify the mount after it is done, so you can not replace the mount with something now owned by the user.",
        "I tested it by adding a sleep() in verify_mount., it results in a weird state.\n\n63 61 253:3 /taviso/testing/bin//deleted /home/taviso\\040(deleted) rw,relatime - ext4 /dev/mapper/vg_thinkstation-lv_home rw,seclabel,barrier=1,data=ordered",
        "And the second verify_mount does not fail.",
        "Yes, you're right, just stating that it's scary that the mount will succeed.\n\nI do not have any specific attack against it.",
        "We new about this race, but not much we can do about it other then verify the final directory is owned by the user.  Since fmount(fd) does not exist.\n\nAs far as the tmpfs wasting resources comments from Steve, I think we should separate them out.  \n\nsandbox is intended to be run multiple times.  Every pdf/.doc file I download from the internet I run a sandbox on.  In the future I could think of people running sandboxes on different firefox instances.  I could even see people using sandbox for MLS desktops, rather then XACE.",
        "(In reply tocomment #45)> Createdattachment 480817[details]> Updated codeNeeds an obvious fix for the asprintf line to compile.\n\nDoes it really need to restrict tmpdir to ~/.sandboxtmp?  Such restriction should also make verify_mount's strncmp(mntdir, \"/tmp\", 4) check redundant, as home is mounted before tmp.\n\n(In reply tocomment #51)> As far as the tmpfs wasting resources comments from Steve, I think we should\n> separate them out.  \n> \n> sandbox is intended to be run multiple times.  Every pdf/.doc file I download\n> from the internet I run a sandbox on.  In the future I could think of people\n> running sandboxes on different firefox instances.sandbox randomizes categories range when generating contexts for the process to be run inside the sandbox.  If you currently run two concurrent sandbox instances with the same tmpdir, the last one's context is set on /tmp, making it unavailable to other instances.\n\nAny suggestion on how to avoid memory hogging via seunshare?  tmpfs default size is 50% of RAM, hence 6 instances should allow user to hog all memory on systems that follow old SWAP = 2 * RAM recommendation.  That still doesn't sound good for something that's installed by default and hard to remove.",
        "I think we still need to make sure the user does not specify /tmp for the homedir, because /tmp will be mounted over.  Not sure if things would work correctly if /tmp/homedir is bind mounted on ~/ and then /tmp is mounted on with a tmpfs.  I guess we could hack this out and see if it works.\n\nPlease provide the asprintf fix needed for compile, since this is compiling on my box.\n\nMount options for tmpfs\n       size=nbytes\n              Override  default  maximum  size of the filesystem.  The size is\n              given in bytes, and rounded up to entire pages.  The default  is\n              half  of  the memory. The size parameter also accepts a suffix %\n              to limit this tmpfs instance to that percentage of your physical\n              RAM:  the default, when neither size nor nr_blocks is specified,\n              is size=50%\n\n\nWe could give a number here.  \n\nSteve has suggested that we have a config file for seunshare that can set limits, maybe even allow admins to specify which users are allowed to use it.  Secondly we could write to /var/run/seunshare/user and record the number of sandboxes that are running.  Then the admin could configure /etc/sandbox.conf with a max number of sandboxes.\n\nmax_tmp=1%\nmax_sessions=20\nusers=*\nor \nusers=dwalsh\nusers=",
        "(In reply tocomment #53)> I think we still need to make sure the user does not specify /tmp for the\n> homedir, because /tmp will be mounted over.The same problem should affect released seunshare versions, right?  They have no problem with use as like: seunshare -h /tmp/a/home -t /tmp/a/tmp command> Please provide the asprintf fix needed for compile, since this is compiling on\n> my box.Attached version contains:\n\n    char *cpbuf=NULL;\n    if (asprintf(&buf, \"/bin/cp -RTp %s/.sandboxtmp /tmp 2> /dev/null\", pwd->pw_dir) < 0) {\n        fprintf(stderr, _(\"Failed to allocate copy command: %s\\n\"), strerror(errno));\n        return -1;\n    }\n\n    rc = system(cpbuf);\n\nand fails to compile with:\n\n  seunshare.c:549: error: \u2018buf\u2019 undeclared (first use in this function)\n\nI suspect you already did \"asprintf(&buf\" -> \"asprintf(&cpbuf\" change after attaching code to bugzilla.> Steve has suggested that we have a config file for seunshare that can set\n> limits, maybe even allow admins to specify which users are allowed to use it. \n> Secondly we could write to /var/run/seunshare/user and record the number of\n> sandboxes that are running.  Then the admin could configure /etc/sandbox.conf\n> with a max number of sandboxes.\n> \n> max_tmp=1%\n> max_sessions=20I agree with max_tmp, but we've already discussed that session tracking needs more work as we can not decrement active session counter after wait()ing for the seunshare's child to exit.  With the robust session tracking in use, is tmpfs still attractive compared to chmoding/chowning directory at the beginning and at the end?\n\n\nThat setfilecon still fails for me, as it's reached after setfsuid call, and uncovers this use-after-free bug:\n\n        rc =setfilecon(\"/tmp\", filecon);\n        freecon(filecon);\n        if (rc < 0) {\n            fprintf(stderr, _(\"Failed to set context %s on /tmp: %s\\n\"), filecon, strerror(errno));",
        "seunshare -h /tmp/home -t /tmp/home/tmp command\nseunshare -h /tmp/tmp/home -t /tmp/tmp command \n\nIs allowed in the release version with some hacky checks for overlaps.\n\nOk, yes I have fixed the code.  Sorry about that.\n\nHow about we dump tmpfs and go with making a tmpdir in /tmp and mount bind over /tmp.  Then I don't need to worry about memory use.  \n\nNot sure why setfilecon works for me and not for you.\n\nMight have something to do with the file system used for /tmp?\n\nI could attempt to do the setfilecon before the setfsuid, but on a rootsquash file system it will not be able to get the file context of the user directory.",
        "(In reply tocomment #55)> How about we dump tmpfs and go with making a tmpdir in /tmp and mount bind over\n> /tmp.  Then I don't need to worry about memory use.What's the tmpdir above?  A directory passed to seunshare as -t argument?  This should work too, if the directory is chowned/chmoded at the beginning properly.  It can't be chowned back seunshare exit though, so sandbox won't have privileges to remove it.  It can remove most of its content though (in most cases, only root:$USER owned directory is expected to be left around), and tmpwatch should take care of the rest over the time.\n\nThis can be combined with some of the ideas from the version using tmpfs.  seunshare can accept arbitrary tmpdir as its argument.  It will create new temporary directory with proper permissions in /tmp, copy/move files to that new temporary directory and bind mount it.  At the end of run, move temporary files back to the original tmpdir (to provide persistence) and remove directory that was bind mounted.  Moving should be done with user privileges, delete with root privs, possibly reusing some of the tmpwatch code to do it safely.\n\nRemoving usable /tmp from the sandboxed processes that are running after seunshare's termination is not a concern, I believe.",
        "Createdattachment 482122[details]Ok this version allocates a directory in /tmp an labels it correctly\n\nIt then rsyncs the homedir/.sandboxtmp direcory to /tmp and when it is done rsync's it back\n\n\nThe reason it has to be a subdir of homedir, is we want to drop capabilities before doing any of the \"rsyncing\".  Since it mounts the tmpdir and the homedir, then drops capabilities, if the /tmp contents are not a subdir of homedir, I can no longer get to the contents.\n\n\nThis seems to work.  Since the /tmp is a subdir of the real /tmp, we end up using the same file system, and quota should work fine.  The only problem I see is around leaving the tmpdirectory in /tmp.  We can not delete it since we have dropped capabilities,  I attempt to remove all files from the directory.  This means we need to wait for tmpreaper to clean up the directories.",
        "Tomas has suggested on line that I change the tmpdir to be \n\nroot,dwalsh,1770.\n\nTavis do you think there is risk in this?",
        "I made this change and created a file owned by root in my /tmp directory,  As dwalsh I tried to delete the file and got.\n\nrm dan\nrm: remove write-protected regular empty file `dan'? y\nrm: cannot remove `dan': Operation not permitted\n\nThis seems like a better solution since a different user could stick a file into my tmpdir with the current patch.",
        "I think that sounds okay, but as Tomas says 1770 is definitely the right permissions.",
        "Createdattachment 482153[details]Yet another version....  This one cleans up after itself.\n\nseunshare now does\n\nseteuid(root)\ncreate the tmpdir,\nforks,\nParent drops_capabilities with euid == 0,\nwaits for the child pid to exit,\n\n\tchildprocess\n        unshares,\n        mounts,\n        drops_capabilities and\n\tsetresuid(dwalsh)\n\trsync ~/.sandboxtmp to /tmp\n\tfork()\n\t\tChild execs program\n\tParent waits for child to exit\n\trsync /tmp to ~/.sandboxtmp\nrmdir(tmpdir)",
        "I guess it will be okay, but only because you can't specify a subdirectory. Otherwise because ruid matches you can STOP it, wait for tmpwatch to clean everything up, then make a symlink.\n\nI think it's a scary design. Is /var/sandbox/tmp-xxxxx with /var/sandbox 0700, not a possibility?\n\nTavis.",
        "rmdir will not follow a symlink.   I am not doing a full cleanup.  just rmdir(tmpdir),  Which will fail if it is anything other then a directory.\n\nWhy do you think /var/sandbox/tmp-xxxx is better, \n\nIt breaks quota.\n\nYou end up with a new random directory where you can dump files.\n\nMy mechanism maintains all files in your homedir. and /tmp.\n\nTomas suggested the 0770.\n\nIf you are running F15 you can download the latest policycoreutils and selinux-policy from brew.  If we get consensus I will push the packages to F13,F14,F15 and RHEL6",
        "(In reply tocomment #63)> rmdir will not follow a symlink.   I am not doing a full cleanup.  just\n> rmdir(tmpdir),  Which will fail if it is anything other then a directory.What Tavis points out is that you can stop seunshare right after mkdtemp, leave it stopped for a couple of days so the temporary directory gets old enough to be removed by tmpwatch, create symlink with the same name and continue seunshare.  If you stop before chmod, seunshare will change permission of the wrong directory.  If you stop before mount, you can mount a directory that is not accessible to the user, or a directory that is user owned and non-sticky.> Why do you think /var/sandbox/tmp-xxxx is betterNot tmpwatch clean-up by default, even if tmpwatch is configured to look there too, user won't be able to create symlink with the name matching directory that was previously removed.",
        "Createdattachment 482691[details]seunshare with post-mount checks\n\nI've added pre-chmod and post-mount check to avoid using unintended directory.\n\nI've also changed the code to fork + drop privs + execute command when needed, i.e. it copies files to a temporary directory before mounting it, so that removes restriction on where the user temporary directory can be located.\n\nThe way rsync is used is not ideal, as it won't preserve permissions and contexts.\n\nI did some testing with seunshare.  sandbox -X evince /tmp/file.pdf works too.  sandbox -M bash does not work quite well in both old and new version, as sandbox_t does not seem to have permissions to access /home.",
        "A quick summary of the changes that were done in response to this bugs:\n\nseunshare now creates a runtime temporary directory owned by root and with the sticky bit set properly.  Files form the user-specified directory are copied to the runtime directory and the changes synced back (using rsync) at the end of the seunshare run.\n\nseunshare was also moved from the policycoreutils subpackage (installed by default on all systems) to policycoreutils-sandbox subpackage.  This subpackage can be easily removed where sandbox functionality is not required, providing a cleaner mitigation for the case of possible future seunshare issues.",
        "Correct",
        "This issue has been addressed in following products:\n\n  Red Hat Enterprise Linux 6\n\nVia RHSA-2011:0414https://rhn.redhat.com/errata/RHSA-2011-0414.html"
    ]
}