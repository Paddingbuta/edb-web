{
    "bugid": "1283358",
    "cveid": [
        "CVE-2016-2184"
    ],
    "summary": "CVE-2016-2184 Local RedHat Enterprise Linux DoS \u2013 RHEL 7.1 Kernel crashes on invalid  USB device descriptors (snd_usb_audio driver bug2) [local-DoS]",
    "alias": "None",
    "product": "Red Hat Enterprise Linux 7",
    "hardware": "Unspecified",
    "os": "Unspecified",
    "url": "",
    "reported_date": "2015-11-18 19:38 UTC byRalf Spenneberg",
    "attachment": [
        "https://bugzilla-attachments.redhat.com/attachment.cgi?id=1096251",
        "https://bugzilla-attachments.redhat.com/attachment.cgi?id=1096252",
        "https://bugzilla-attachments.redhat.com/attachment.cgi?id=1096253",
        "https://bugzilla-attachments.redhat.com/attachment.cgi?id=1141881",
        "https://bugzilla-attachments.redhat.com/attachment.cgi?id=1141885",
        "https://bugzilla-attachments.redhat.com/attachment.cgi?id=1141886"
    ],
    "comment": [
        "Description of problem:\nLocal RedHat Enterprise Linux DoS \u2013 RHEL 7.1 Kernel crashes on invalid \nUSB device descriptors (snd_usb_audio driverbug2) [local-DoS]\n\nVersion-Release number of selected component (if applicable):\nKernel-Version: 3.10.0-229.20.1.el7.x86_64 \n\nHow reproducible:\nalways\n\nOpenSource Security Ralf Spenneberg\nAm Bahnhof 3-5\n48565 Steinfurt\ninfo\n\n\nDate: November 12th, 2015\nAuthors: Sergej Schumilo, Hendrik Schwartke, Ralf Spenneberg\nCVE: not yet assigned\nCVSS: 4.9 (AV:L/AC:L/Au:N/C:N/I:N/A:C) \nTitle: Local RedHat Enterprise Linux DoS \u2013 RHEL 7.1 Kernel crashes on invalid \nUSB device descriptors (snd_usb_audio driver) [local-DoS]\nSeverity: Critical. The Kernel panics. A reboot is required.\nEase of Exploitation: Trivial\nVulnerability type: Wrong input validation\nProducts: RHEL 7.1 including all updates\nKernel-Version: 3.10.0-229.20.1.el7.x86_64 \n(for debugging-purposes we used the CentOS Kernel kernel-debuginfo-3.10.0-229.14.1.el7)\n\n\nAbstract\nThe Kernel 3.10.0-229.20.1.el7.x86_64 crashes when presented a buggy USB \ndevice which requires the snd_usb_audio driver.\nDetailed product description\nWe confirmed the bug on the following system:\nRHEL 7.1\nKernel = 3.10.0-229.20.1.el7.x86_64\nFurther products or kernel versions have not been tested.\nHow reproducible: Always\nActual results: Kernel crashes \n\nDescription:\nThe bug was found using the USB-fuzzing framework vUSBf from Sergej Schumilo \n(github.com/schumilo) using the following device descriptor:\n\n ######### PAYLOAD 1 #########\n[*] Device-Descriptor\n  bLength:\t\t0x12\n  bDescriptorType:\t0x1\n  bcdUSB:\t\t0x200\n  bDeviceClass:\t\t0x3\n  bDeviceSubClass:\t0x0\n  bDeviceProtocol:\t0x0\n  bMaxPacketSize:\t0x40\n  idVendor:\t\t0x582\n  idProduct:\t\t0x0\n  bcdDevice:\t\t0x100\n  iManufacturer:\t0x1\n  iProduct:\t\t0x2\n  iSerialNumbers:\t0x3\n  bNumConfigurations:\t0x1\n\nThis is the configuration descriptor containing the malicious value for \nbNumEndpoints causing the crash. A zero value for bNumEndpoints crashes the system.\n\n\t[*] Configuration-Descriptor\n\t  bLength:\t\t0x9\n\t  bDescriptorType:\t0x2\n\t  wTotalLength:\t\t0x27\n\t  bNumInterfaces:\t0x1\n\t  bConfigurationValue:\t0x1\n\t  iConfiguration:\t0x0\n\t  bmAttributes:\t\t0x0\n\t  bMaxPower:\t\t0x31\n\t\t[*] Interface-Descriptor\n\t\t  bLength:\t\t0x9\n\t\t  bDescriptorType:\t0x4\n\t\t  bInterfaceNumber:\t0x0\n\t\t  bAlternateSetting:\t0x0\n\t\t  bNumEndpoints:\t0x3\n\t\t  bInterfaceClass:\t0x0\n\t\t  bInterfaceSubClass:\t0x0\n\t\t  bInterfaceProtocol:\t0x0\n\t\t\t[*] Endpoint-Descriptor\n\t\t\t  bLength:\t\t0x7\n\t\t\t  bDescriptorType:\t0x5\n\t\t\t  bEndpointAddress:\t0x81\n\t\t\t  bmAttribut:\t\t0x3\n\t\t\t  wMaxPacketSize:\t0x404\n\t\t\t  bInterval:\t\t0xc\n\t\t\t[*] Endpoint-Descriptor\n\t\t\t  bLength:\t\t0x7\n\t\t\t  bDescriptorType:\t0x5\n\t\t\t  bEndpointAddress:\t0x1\n\t\t\t  bmAttribut:\t\t0x2\n\t\t\t  wMaxPacketSize:\t0x4\n\t\t\t  bInterval:\t\t0xc\n\t\t\t[*] Endpoint-Descriptor\n\t\t\t  bLength:\t\t0x7\n\t\t\t  bDescriptorType:\t0x5\n\t\t\t  bEndpointAddress:\t0x82\n\t\t\t  bmAttribut:\t\t0x1\n\t\t\t  wMaxPacketSize:\t0x4\n\t\t\t  bInterval:\t\t0xc\n\nProof of Concept:\n1) The bug can be reproduced using USB-fuzzing framework vUSBf from Sergej Schumilo (github.com/schumilo). \nThe attached vUSBf-obj file contains the payload. Please let us know if you would like to use the Facedancer board. \nIn such case, we could also provide a patched version of vUSBf which allows to reproduce vUSBf-Payloads using the Facedancer board.\n2) For a proof of concept we are providing also an Arduino firmware file. Just flash it \non Arduino Leonardo and plug it into any RHEL machine. The Arduino will \nemulate the defective USB device.\n\n   avrdude -v -p ATMEGA32u4 -c avr109 -P /dev/ttyACM0 -b 57600 -U flash:w:binary.hex\n\nThe file binary.hex has been attached to this bug report.\nTo prevent automated sending of payloads, use a jumper to connect port D3 and \n5V!\n\n\nSeverity and Ease of Exploitation\nThe security weakness can be easily exploited. Using our Arduino firmware only \nphysical access to the system is required. \n\n\nAdditional info:\nStacktrace, vUSBf-Payload, Arduino-Firmware attached.\n\n\nPlease assign a CVE for this issue since this is a local DoS of the targeted system. \nCVSS 4.9 (AV:L/AC:L/Au:N/C:N/I:N/A:C)",
        "Createdattachment 1096251[details]vUSBf Payload",
        "Createdattachment 1096252[details]Stacktrace",
        "Createdattachment 1096253[details]Arduino firmware demonstrating the bug",
        "CVE-2016-2184which is Red Hat's private CVE ID was assigned to this security flaw. Please, use it in the public communications regarding this flaw, thank you.",
        "Public via:http://seclists.org/bugtraq/2016/Mar/89",
        "Research:\n\n1) Even after the upstream commits 0f886ca1, 902eb7fd and 447d6275f (many thanks to Takashi Iwai) there is a double-free bug in [snd-usb-audio] module due to alloc/free logic flaw in snd_usb_add_audio_stream() function. A double-free leads to kernel structure/list/slab corruptions and shortly to null-deref, GPF or lockup.\n\n2.1) Let me describe what happens with the current code in usb_audio_probe(), create_fixed_stream_quirk() and snd_usb_add_audio_stream():> [ sound/usb/card.c ]\n> static int usb_audio_probe(struct usb_interface *intf,\n>                            const struct usb_device_id *usb_id)\n> {\n>         ...\n>         if (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {\n>                 /* need some special handlings */\n>                 err = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk);\n>                 if (err < 0)\n>                         goto __error;\n>         }\n>         ...\n>  __error:\n>         if (chip) {\n>                 if (!chip->num_interfaces)\n>                         snd_card_free(chip->card);Somewhere in the middle of usb_audio_probe() the function snd_usb_create_quirk() is called, and if it returns with an error and no interfaces were created, the sound card is destroyed with \"snd_card_free(chip->card)\".\n\n2.2) create_fixed_stream_quirk() is called from snd_usb_create_quirk():> [ sound/usb/quirks.c ]\n> static int create_fixed_stream_quirk(struct snd_usb_audio *chip,\n>                                      struct usb_interface *iface,\n>                                      struct usb_driver *driver,\n>                                      const struct snd_usb_audio_quirk *quirk)\n> {\n>         struct audioformat *fp;\n>         struct usb_host_interface *alts;\n>         struct usb_interface_descriptor *altsd;\n>         ...\n>         fp = kmemdup(quirk->data, sizeof(*fp), GFP_KERNEL);\n>         ...\n> (*)     stream = (fp->endpoint & USB_DIR_IN)\n> (*)             ? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;\n> (*)     err = snd_usb_add_audio_stream(chip, stream, fp);\n> (*)     if (err < 0)\n> (*)             goto error;\n> \n>         if (fp->iface != get_iface_desc(&iface->altsetting[0])->bInterfaceNumber ||\n>             fp->altset_idx >= iface->num_altsetting) {\n>                 err = -EINVAL;\n>                 goto error;\n>         }\n>         alts = &iface->altsetting[fp->altset_idx];\n>         altsd = get_iface_desc(alts);\n>         if (altsd->bNumEndpoints < 1) {\n>                 err = -EINVAL;\n>                 goto error;\n>         }\n>         ...\n>  error:\n>         kfree(fp);\n>         kfree(rate_table);\n>         return err;\n> }2.3) *fp is allocated and passed to snd_usb_add_audio_stream() where snd_usb_init_substream() is called:> [ sound/usb/stream.c ]\n> int snd_usb_add_audio_stream(struct snd_usb_audio *chip,\n>                              int stream,\n>                              struct audioformat *fp)\n> {\n>         struct snd_usb_stream *as;\n>         struct snd_usb_substream *subs;\n>         struct snd_pcm *pcm;\n>         ...\n>         /* create a new pcm */\n>         as = kzalloc(sizeof(*as), GFP_KERNEL);\n>         ...\n>         snd_usb_init_substream(as, stream, fp);2.4) In turn snd_usb_init_substream() adds audioformat *fp by its &fp->list to substream's fmt_list list:> [ sound/usb/stream.c ]\n> static void snd_usb_init_substream(struct snd_usb_stream *as,\n>                                    int stream,\n>                                    struct audioformat *fp)\n> {\n>         struct snd_usb_substream *subs = &as->substream[stream];\n> \n>         INIT_LIST_HEAD(&subs->fmt_list);\n>         ...\n>         list_add_tail(&fp->list, &subs->fmt_list);\n>         subs->num_formats++;2.5) Things go bad from this point in case snd_usb_add_audio_stream() or the caller go the error path. The bug is that the caller frees (see \"error: kfree(fp);\" code) *fp on the error path, BUT the pointer to the already-freed memory remains in the substream's fmt_list list.\n\nThe double-free happens after create_fixed_stream_quirk() returns with an error and usb_audio_probe() calls snd_card_free()->...->snd_usb_audio_pcm_free()->free_substream(). As subs->fmt_list is already corrupted, iterating it with list_for_each_entry_safe() leads to any and unpredictable results.> static void free_substream(struct snd_usb_substream *subs)\n> {\n>         struct audioformat *fp, *n;\n>         ...\n>         list_for_each_entry_safe(fp, n, &subs->fmt_list, list) {\n>         ...\n>                 kfree(fp);3.1) The crash is reproduceable by faking the USB device with no endpoints as described inhttps://bugzilla.redhat.com/show_bug.cgi?id=1283355andhttps://bugzilla.redhat.com/show_bug.cgi?id=1283358.\n\nPlease see as a proof the following kernel log with debug printing added to the code. First, *fp is added to fmt_list in snd_usb_init_substream():\n\n[  322.797223] usb 1-1: new full-speed USB device number 2 using xhci_hcd\n[  322.974083] usb 1-1: config 1 interface 0 altsetting 0 has 3 endpoint descriptors, different from the interface descriptor's value: 0\n[  322.987031] usb 1-1: New USB device found, idVendor=045e, idProduct=0283\n[  322.998318] usb 1-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3\n[  323.083913] media: Linux media interface: v0.10\n[  323.231249] init_substream: add_tail() fp=ffff88003364ba80 fp->list.next=ffff8800b1e898b8 fp->list.prev=ffff8800b1e898b8 fmt_list=ffff8800b1e898b8 fmt_list.next=ffff88003364ba80 prev=ffff88003364ba80 num_formats=1\n\nAs you can see we have a correct list here with head at fmt_list=ffff8800b1e898b8 and single element fp=ffff88003364ba80.\n\n3.2) The code finds out that there are too few endpoints present and goes the error path (to the \"error:\" label):\n\n[  323.307927] usb 1-1: too few endpoints\n[  323.312964] trace-before-free: substream-0 ffff8800b1e89818 numf 1 fmt_list ffff8800b1e898b8 next ffff88003364ba80\n[  323.353759] fp=ffff88003364ba80 next=ffff8800b1e898b8 prev=ffff8800b1e898b8 rate=(null) chmap=(null)\n[  323.362118] struct sane\n\nAs you can see the substream's fmt_list is sane at this point.\n\n3.3) After \"kfree(fp)\" in the error path of create_fixed_stream_quirk() *fp is freed, BUT the pointer to the freed memory remains in fmt_list. After *fp is freed the list is corrupted and contains trash:\n\n[  323.371752] KFREE(fp) ffff88003364ba80\n[  323.380383] trace-after-free: substream-0 ffff8800b1e89818 numf 1 fmt_list ffff8800b1e898b8 next ffff88003364ba80\n[  323.400003] fp=ffff88003364ba80 next=ffff88003364bf80 prev=ffff8800b1e898b8 rate=(null) chmap=(null)\n[  323.406786] fp=ffff88003364bf80 next=          (null) prev=          (null) rate=(null) chmap=(null)\n[  323.422211] next == NULL: FAIL, struct INSANE\n[  323.436706] KFREE(rate_table) (null)\n\n3.4) After error return from create_fixed_stream_quirk() the sound card is destroyed with \"snd_card_free(chip->card)\" in usb_audio_probe(). In the end free_substream() is called:\n\n[  323.511256] usb 1-1: snd_usb_create_quirk() failed: -22\n[  323.565108] list_for_each_entry_safe(): fp=ffff88003364ba80 n=ffff88003364bf80\n[  323.586337] kfree fp ffff88003364ba80                                  <<< DOUBLE-FREE\n[  323.588509] loop-end: fp=ffff88003364ba80 n=ffff88003364bf80\n[  323.599969] list_for_each_entry_safe(): fp=ffff88003364bf80 n=(null)\n[  323.610460] kfree fp ffff88003364bf80                                  <<< FREEING SOMEONE ELSE'S MEMORY\n[  323.613181] loop-end: fp=ffff88003364bf80 n=(null)                     <<< NULL-PTR DEREF\n...\n[  324.247113] BUG: unable to handle kernel NULL pointer dereference at           (null)\n[  324.247533] IP: [<ffffffffc02d40ef>] free_substream.part.0+0xef/0x100 [snd_usb_audio]\n[  324.248088] PGD 0 \n[  324.248088] Oops: 0000 [#1] SMP \n[  324.248088] Modules linked in: snd_usb_audio(+) snd_usbmidi_lib snd_hwdep ...\n[  324.248088] CPU: 2 PID: 767 Comm: systemd-udevd Not tainted 4.5.0-vladis #25\n[  324.248088] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.8.2-0-g33fbe13 by qemu-project.org 04/01/2014\n[  324.248088] task: ffff880034718000 ti: ffff8800b2fbc000 task.ti: ffff8800b2fbc000\n[  324.248088] RIP: 0010:[<ffffffffc02d40ef>]  [<ffffffffc02d40ef>] free_substream.part.0+0xef/0x100 [snd_usb_audio]\n[  324.248088] RSP: 0018:ffff8800b2fbf898  EFLAGS: 00010217\n...\n[  324.248088] Call Trace:\n[  324.248088]  [<ffffffffc02d43fa>] snd_usb_audio_pcm_free+0x9a/0xa0 [snd_usb_audio]\n[  324.248088]  [<ffffffffc028d982>] snd_pcm_free+0x32/0xa0 [snd_pcm]\n[  324.248088]  [<ffffffffc028da02>] snd_pcm_dev_free+0x12/0x20 [snd_pcm]\n[  324.248088]  [<ffffffffc027d279>] __snd_device_free+0x29/0x70 [snd]\n[  324.248088]  [<ffffffffc027d660>] snd_device_free_all+0x30/0x60 [snd]\n[  324.248088]  [<ffffffffc02777a4>] release_card_device+0x34/0x90 [snd]\n[  324.248088]  [<ffffffff815ae2b2>] device_release+0x32/0x90\n[  324.248088]  [<ffffffff81455f8a>] kobject_release+0x7a/0x190\n[  324.248088]  [<ffffffff81455e47>] kobject_put+0x27/0x50\n[  324.248088]  [<ffffffff815ae5f7>] put_device+0x17/0x20\n[  324.248088]  [<ffffffffc0277b57>] snd_card_free+0x67/0x90 [snd]\n[  324.248088]  [<ffffffffc02c4f14>] usb_audio_probe+0x754/0x9d0 [snd_usb_audio]\n...\n\n4.1) The suggested patch consists of 2 changes. First, I suppose we should move the code in create_fixed_stream_quirk() marked as \"(*)\" (see above) after \"if (altsd->bNumEndpoints < 1)\" check. This way no allocations is done if we go an error path. I've checked that fp->iface and fp->altset_idx are not changed in snd_usb_add_audio_stream() and functions called from it, so it is safe to swap these 2 pieces of code.\n\n4.2) The problem with double-free still remains. I've verified that all the callers of snd_usb_add_audio_stream() free *fp in case of error:\n\n$ git grep snd_usb_add_audio_stream\nsound/usb/quirks.c:     err = snd_usb_add_audio_stream(chip, stream, fp);> *        err = snd_usb_add_audio_stream(chip, stream, fp);\n> *        if (err < 0)\n> *                goto error;\n> * error:\n> *        kfree(fp);\n> *        kfree(rate_table);\n> *        return err;sound/usb/quirks.c:     err = snd_usb_add_audio_stream(chip, stream, fp);> *        err = snd_usb_add_audio_stream(chip, stream, fp);\n> *        if (err < 0) {\n> *                kfree(fp);\n> *                return err;\n> *        }sound/usb/stream.c:             err = snd_usb_add_audio_stream(chip, stream, fp);> *                err = snd_usb_add_audio_stream(chip, stream, fp);\n> *                if (err < 0) {\n> *                        kfree(fp->rate_table);\n> *                        kfree(fp->chmap);\n> *                        kfree(fp);\n> *                        return err;\n> *                }This means that snd_usb_add_audio_stream() should remove *fp from the substream's fmt_list list on the error path, if it was already added. Such places are:> int snd_usb_add_audio_stream(struct snd_usb_audio *chip, int stream, struct audioformat *fp)\n> {\n>         struct snd_usb_stream *as;\n>         struct snd_usb_substream *subs;\n>         struct snd_pcm *pcm;\n>         int err;\n> \n>         list_for_each_entry(as, &chip->pcm_list, list) {\n>                 subs = &as->substream[stream];\n>                 ...\n>                         list_add_tail(&fp->list, &subs->fmt_list); <<< ADDING fp HERE\n>                         subs->num_formats++;\n>                         return 0;                                  <<< NO ERROR PATH HERE\n>                 }\n>         }\n> \n>         /* look for an empty stream */\n>         list_for_each_entry(as, &chip->pcm_list, list) {\n>                 subs = &as->substream[stream];\n>                 ...\n>                 snd_usb_init_substream(as, stream, fp);  <<< ADDING fp HERE, IF add_chmap() FAILS\n>                 return add_chmap(as->pcm, stream, subs); <<< fp SHOULD BE REMOVED FROM fmt_list\n>         }\n> \n>         /* create a new pcm */\n>         as = kzalloc(sizeof(*as), GFP_KERNEL);\n>         err = snd_pcm_new(chip->card, \"USB Audio\", chip->pcm_devs,\n>         ...\n>         if (err < 0) {            <<< fp IS NOT ADDED YET HERE, SO FINE\n>                 kfree(as);\n>                 return err;\n>         }\n>         ...\n>         snd_usb_init_substream(as, stream, fp);                 <<< ADDING fp HERE\n>         ...                                                     <<< IF add_chmap() FAILS fp SHOULD\n>         return add_chmap(pcm, stream, &as->substream[stream]);  <<< BE REMOVED FROM fmt_list\n> }add_chmap() itself does not add anything to fmt_list list, so we indeed need to remove only the single list element from the list. Having all the above in mind, the patch follows.\n\n4.3) How to handle possible error paths after successful call to snd_usb_add_audio_stream() in create_fixed_stream_quirk() is d\niscussable. Properly it should be like the below, but I believe it is overcomplication here would and stick to a simple error_after_add_audio_stream: label:>  error2:\n>         snd_usb_del_audio_stream(...something...);\n>  error:\n>         kfree(fp);\n>         kfree(rate_table);\n>         return err;",
        "Createdattachment 1141881[details]research.txt",
        "Createdattachment 1141884[details]snd-usb-audio-double-free.patch",
        "Createdattachment 1141885[details]dmesg-9-max-debug.txt",
        "Createdattachment 1141886[details]dmesg-6-more-debug.txt",
        "Createdattachment 1142228[details]snd-usb-audio-double-free-v2.patch",
        "Research:http://mailman.alsa-project.org/pipermail/alsa-devel/2016-March/106316.htmlFinal patch in alsa-devel@, linux-kernel@, linux-sound@ lists:http://mailman.alsa-project.org/pipermail/alsa-devel/2016-March/106393.html",
        "Thank you for reporting this flaw. The Product Security has rated this flaw as having low security impact (bz#1317012), so the patch is currently not planned to be added to the RHEL source trees. If accepted to the upstream, the patch may get to the RHEL trees later at the next USB subsystem code rebase."
    ]
}