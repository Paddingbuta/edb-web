{
    "bugid": "1788421",
    "cveid": [
        "CVE-2019-2038"
    ],
    "summary": "CVE-2019-20382 virt:8.1/qemu-kvm: QEMU: vnc: memory leakage upon disconnect [rhel-av-8]",
    "alias": "None",
    "product": "Red Hat Enterprise Linux Advanced Virtualization",
    "hardware": "Unspecified",
    "os": "Unspecified",
    "url": "",
    "reported_date": "2020-01-07 06:57 UTC byHan Han",
    "attachment": [
        "https://bugzilla-attachments.redhat.com/attachment.cgi?id=1650300"
    ],
    "comment": [
        "Createdattachment 1650300[details]valgrind log\n\nDescription of problem:\nAs subject\n\nVersion-Release number of selected component (if applicable):\nqemu-kvm-4.1.0-20.module+el8.1.1+5309+6d656f05.x86_64\n\nHow reproducible:\n100%\n\nSteps to Reproduce:\n1. Start a qemu with vnc together with valgrind\n# valgrind --log-file=vnc-memleak.log --leak-check=full /usr/libexec/qemu-kvm -vnc 0.0.0.0:0\n\n\n2. Use remote-viewer to connect vnc for some times\n# for i in {1..10};do timeout -s INT 2 remote-viewer vnc://[HOST_IP]:5900;done\n\nYou can also start qemu directly and connect vnc for some times. Check the rss useage increasing on qemu process.\n\n3. Memleak log:\n==24942== 131,072 bytes in 1 blocks are possibly lost in loss record 4,662 of 4,683\n==24942==    at 0x4C331EA: calloc (vg_replace_malloc.c:762)\n==24942==    by 0x556122D: g_malloc0 (in /usr/lib64/libglib-2.0.so.0.5600.4)\n==24942==    by 0x78B66B3: deflateInit2_ (in /usr/lib64/libz.so.1.2.11)\n==24942==    by 0x68FBAD: tight_init_stream (vnc-enc-tight.c:798)\n==24942==    by 0x68FBAD: tight_compress_data (vnc-enc-tight.c:850)\n==24942==    by 0x69192F: send_palette_rect (vnc-enc-tight.c:1132)\n==24942==    by 0x69192F: send_sub_rect_nojpeg (vnc-enc-tight.c:1414)\n==24942==    by 0x69192F: send_sub_rect (vnc-enc-tight.c:1514)\n==24942==    by 0x69292E: find_large_solid_color_rect (vnc-enc-tight.c:1614)\n==24942==    by 0x69292E: tight_send_framebuffer_update (vnc-enc-tight.c:1675)\n==24942==    by 0x69294E: find_large_solid_color_rect (vnc-enc-tight.c:1617)\n==24942==    by 0x69294E: tight_send_framebuffer_update (vnc-enc-tight.c:1675)\n==24942==    by 0x692AB0: find_large_solid_color_rect (vnc-enc-tight.c:1633)\n==24942==    by 0x692AB0: tight_send_framebuffer_update (vnc-enc-tight.c:1675)\n==24942==    by 0x692AB0: find_large_solid_color_rect (vnc-enc-tight.c:1633)\n==24942==    by 0x692AB0: tight_send_framebuffer_update (vnc-enc-tight.c:1675)\n==24942==    by 0x692AB0: find_large_solid_color_rect (vnc-enc-tight.c:1633)\n==24942==    by 0x692AB0: tight_send_framebuffer_update (vnc-enc-tight.c:1675)\n==24942==    by 0x68A104: vnc_send_framebuffer_update (vnc.c:910)\n==24942==    by 0x69D3C0: vnc_worker_thread_loop (vnc-jobs.c:262)\n==24942== \n==24942== 262,144 bytes in 2 blocks are possibly lost in loss record 4,665 of 4,683\n==24942==    at 0x4C331EA: calloc (vg_replace_malloc.c:762)\n==24942==    by 0x556122D: g_malloc0 (in /usr/lib64/libglib-2.0.so.0.5600.4)\n==24942==    by 0x78B66DD: deflateInit2_ (in /usr/lib64/libz.so.1.2.11)\n==24942==    by 0x68FBAD: tight_init_stream (vnc-enc-tight.c:798)\n==24942==    by 0x68FBAD: tight_compress_data (vnc-enc-tight.c:850)\n==24942==    by 0x691712: send_mono_rect (vnc-enc-tight.c:1015)\n==24942==    by 0x691712: send_sub_rect_nojpeg (vnc-enc-tight.c:1412)\n==24942==    by 0x691712: send_sub_rect (vnc-enc-tight.c:1514)\n==24942==    by 0x692BC8: tight_send_framebuffer_update (vnc-enc-tight.c:1667)\n==24942==    by 0x692BC8: tight_send_framebuffer_update (vnc-enc-tight.c:1644)\n==24942==    by 0x69294E: find_large_solid_color_rect (vnc-enc-tight.c:1617)\n==24942==    by 0x69294E: tight_send_framebuffer_update (vnc-enc-tight.c:1675)\n==24942==    by 0x68A104: vnc_send_framebuffer_update (vnc.c:910)\n==24942==    by 0x69D3C0: vnc_worker_thread_loop (vnc-jobs.c:262)\n==24942==    by 0x69D5AF: vnc_worker_thread (vnc-jobs.c:324)\n==24942==    by 0x773953: qemu_thread_start (qemu-thread-posix.c:502)\n==24942==    by 0xA0B42DD: start_thread (in /usr/lib64/libpthread-2.28.so)\n\n\nActual results:\nmemory leak.\n\nExpected results:\nno leak\n\nAdditional info:\nNot reproduced on qemu-kvm-4.2.0-4.module+el8.2.0+5220+e82621dc.x86_64 and qemu-kvm-rhev-2.12.0-38.el7.x86_64\n\nI find a vnc memleak fix on upstream 4.2:\n\ncommit 6bf21f3d83\nAuthor: Li Qiang <liq3ea>\nDate:   Sat Aug 31 08:39:22 2019 -0700\n\n    vnc: fix memory leak when vnc disconnect\n    \n    Currently when qemu receives a vnc connect, it creates a 'VncState' to\n    represent this connection. In 'vnc_worker_thread_loop' it creates a\n    local 'VncState'. The connection 'VcnState' and local 'VncState' exchange\n    data in 'vnc_async_encoding_start' and 'vnc_async_encoding_end'.\n    In 'zrle_compress_data' it calls 'deflateInit2' to allocate the libz library\n    opaque data. The 'VncState' used in 'zrle_compress_data' is the local\n    'VncState'. In 'vnc_zrle_clear' it calls 'deflateEnd' to free the libz\n    library opaque data. The 'VncState' used in 'vnc_zrle_clear' is the connection\n    'VncState'. In currently implementation there will be a memory leak when the\n    vnc disconnect. Following is the asan output backtrack:\n    \n    Direct leak of 29760 byte(s) in 5 object(s) allocated from:\n        0 0xffffa67ef3c3 in __interceptor_calloc (/lib64/libasan.so.4+0xd33c3)\n        1 0xffffa65071cb in g_malloc0 (/lib64/libglib-2.0.so.0+0x571cb)\n        2 0xffffa5e968f7 in deflateInit2_ (/lib64/libz.so.1+0x78f7)\n        3 0xaaaacec58613 in zrle_compress_data ui/vnc-enc-zrle.c:87\n        4 0xaaaacec58613 in zrle_send_framebuffer_update ui/vnc-enc-zrle.c:344\n        5 0xaaaacec34e77 in vnc_send_framebuffer_update ui/vnc.c:919\n        6 0xaaaacec5e023 in vnc_worker_thread_loop ui/vnc-jobs.c:271\n        7 0xaaaacec5e5e7 in vnc_worker_thread ui/vnc-jobs.c:340\n        8 0xaaaacee4d3c3 in qemu_thread_start util/qemu-thread-posix.c:502\n        9 0xffffa544e8bb in start_thread (/lib64/libpthread.so.0+0x78bb)\n        10 0xffffa53965cb in thread_start (/lib64/libc.so.6+0xd55cb)\n    \n    This is because the opaque allocated in 'deflateInit2' is not freed in\n    'deflateEnd'. The reason is that the 'deflateEnd' calls 'deflateStateCheck'\n    and in the latter will check whether 's->strm != strm'(libz's data structure).\n    This check will be true so in 'deflateEnd' it just return 'Z_STREAM_ERROR' and\n    not free the data allocated in 'deflateInit2'.\n    \n    The reason this happens is that the 'VncState' contains the whole 'VncZrle',\n    so when calling 'deflateInit2', the 's->strm' will be the local address.\n    So 's->strm != strm' will be true.\n    \n    To fix this issue, we need to make 'zrle' of 'VncState' to be a pointer.\n    Then the connection 'VncState' and local 'VncState' exchange mechanism will\n    work as expection. The 'tight' of 'VncState' has the same issue, let's also turn\n    it to a pointer.\n    \n    Reported-by: Ying Fang <fangying1>\n    Signed-off-by: Li Qiang <liq3ea>\n    Message-id: 20190831153922.121308-1-liq3ea\n    Signed-off-by: Gerd Hoffmann <kraxel>\n\n\nWe can backport it to downstream 4.1.\n\nI am not sure if other version are affected. Please check it.\nFor the impact, it should be a security issue. Because malicious vnc connnector and make use of it to run out of host memory.",
        "QEMU has been recently split into sub-components and as a one-time operation to avoid breakage of tools, we are setting the QEMU sub-component of this BZ to \"General\". Please review and change the sub-component if necessary the next time you review this BZ. Thanks",
        "Verified percomment 9",
        "Since the problem described in this bug report should be\nresolved in a recent advisory, it has been closed with a\nresolution of ERRATA.\n\nFor information on the advisory, and where to find the updated\nfiles, follow the link below.\n\nIf the solution does not work for you, open a new bug report.https://access.redhat.com/errata/RHBA-2020:2017"
    ]
}