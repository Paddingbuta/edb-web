{
    "bugid": "180663",
    "cveid": [
        "CVE-2006-4814"
    ],
    "summary": "CVE-2006-4814 Race condition in mincore can cause \"ps -ef\" to hang",
    "alias": "None",
    "product": "Red Hat Enterprise Linux 4",
    "hardware": "All",
    "os": "Linux",
    "url": "",
    "reported_date": "2006-02-09 19:56 UTC byDoug Chapman",
    "attachment": [
        "https://bugzilla-attachments.redhat.com/attachment.cgi?id=124452"
    ],
    "comment": [
        "Description of problem:\nThere is a race condition that can be easily triggered by the mincore system\ncall that will cause \"ps -ef\" (and likley other things that need to lock\nmmap_sem) to hang.  Since this can be used as a DOS attack I am considering this\na security issue.\n\nI can easily reproduce this on my ia64 hardware.  I do not expect it to be\nhardware specific however (but I will verify when I get access to other hardware).\n\nThe situation that causes this is:\n\n1. thread A calls mincore with the *vec argument pointing to a page that is not\nin core (i.e. a freshly mmapped page).  In the mincore system call it calls\ndown_read on mmap_sem.\n\n2. a second thread in the same process calls mmap to map a new page, this calls\ndown_write on mmap_sem but blocks due to the reader in the first thread.\n\n3. the first thread then calls copy_to_user to copy the info regarding which\npages are in core to the address specified by *vec.  Since this page is not yet\nin core a page fault is triggered.  The page fault handler calls down_read on\nmmap_sem even though this task already has a read lock on it.  Since there is a\nwaiting writer this call to down_read blocks.  Since this is the thread with the\noriginal read_lock on mmap_sem we have deadlock.\n\n4. the DOS issue then comes from any user doing a \"ps -ef\" which needs to do\ndown_read on mmap_sem for each process.  This blocks.\n\n\nVersion-Release number of selected component (if applicable):\nSeen on the latest RHEL4 kernel (2.6.9-30) but is also broken up stream.  I will\ncheck RHEL3 soon.\n\nHow reproducible:\nAll the time (on ia64 SMP however I expect this is not arch dependent)\n\n\nSteps to Reproduce:\n1. compile the attached reproducer with \"cc mincore_hang.c -lpthread\"\n2. ./a.out\n3. ps -ef\n  \nActual results:\nThe a.out and ps -ef hang and are uninterruptable\n\nExpected results:\n\n\nAdditional info:",
        "Createdattachment 124452[details]reproducer for mincore race condition",
        "You got a kernel patch to fix it?  Or a suggestion how\nto fix it?",
        "I have done some thinking on how to fix this.  Since we need to be holding the\nread lock on mmap_sem while walking the vma list perhaps instead of copying the\ninfo into user space while holding the lock we could copy into some kmalloc'ed\nmemory temporarily and the copy_to_user after we drop the read lock.  I don't\nreally like this solution since it means allocating potentially large chunks via\nkmalloc (i.e. some really big app on a 1TB system wants to check all of its\nmemory to see what is in core).\n\nPerhaps a better solution would be to ensure the memory pointed to by *vec is in\ncore before we take the lock and mlock it temporarily.",
        "As you surmise, it reproduces on a RHEL4 x86_64, and on\na UP ia64 RHEL3 box.  \n\nAmazing nobody's ever run into this.> Perhaps a better solution would be to ensure the memory pointed to by *vec\n> is in core before we take the lock and mlock it temporarily.It would seem to make sense to pre-read the memory pointed\nto by vec, as opposed to only doing access_ok() on it.\nPinning the pages from inside the kernel of scares me though,\nbecause nothing prevents the user from passing a ridiculously\nlarge block of address space, even if it's a byte array.\n\nAdding Larry to the cc: list in case he has any suggestions.",
        "Doug,\n\nCarrying your suggestion a bit further, perhaps a fault-and-pin-page\noperation could be done a page a time, by enclosing the \"while (vma)\"\nloop in sys_mincore() inside another while loop that does the operation\non a page-by-page basis (i.e., per page full of byte markers).  Even\nthough *vec at a minimum points to a single page, on a large user virtual\naddress space, a user could still seemingly cause some damage if all of\nits *vec memory were locked down at once.  Doing it a page at time will make\nsys_mincore() obfuscated, but wouldn't introduce a new problem to fix\nthe old one.",
        "Dave,\n\nI had to think this through and stare at the code a bit but it sounds like this\nis probably the best solution.  The first pass through the loop would be special\nsince *vec likley isn't page aligned so we need to see how many bytes we have\nbefore we hit the page boundary and only look at that many pages on the first\npass.  Most of the time it would likely only be 1 pass so I don't think\nperformance is impacted (not that mincore is probably a major performance\nconcern anyway but I bet oracle uses it).",
        "Yep, I forgot about *vec not being on page boundary...\n\nBut you're right -- it still means taking the user's passed-in\nstart, length, and its base pointer to *vec, and keeping local,\nprogressive, versions of those values for each time through the\nloop.\n\nRe: performance, my only concern was memory page locking, i.e.,\nthat it shouldn't do more than one at a time.",
        "QE ack for 4.5.",
        "Ok -- I took a quick look at what data is available in IT #98736.\n\nAside from the fact that there are a number of processes blocked in ps\nin IT #98736, can you explain what that has to do with the mincore() issue\nthat this bugzilla was filed against?  In this bugzilla, Doug forced the\nthe hang with a multi-threaded process whose threads are doing mincore()\nand mmap() operations on their address space simultaneously, leading to\na block on their common mmap_sem semaphore if somebody else then did\na ps on that task.\n\nIn IT #98736, the straces show a bunch of processes that mostly are blocked\ndoing read()'s of various /proc/<pid>/cmdline files.  Are there simultaneous\nthreads doing mincore() calls on the same pids, presuming that they are\nmulti-threaded processes?\n\nAnyway, at a minimum, we need a forced crash-dump to figure out what's\ngoing on in the IT's case.  A bunch of user-space \"strace\" outputs are pretty\nmuch useless, especially those of the \"ps\" commands (as opposed to the pids\nwho cmdline's are being read.  \n\nAnd if it has nothing to do with simultaneous mincore()/mmap() operations\ngoing on in the same threads whose /proc/pid/cmdline files are being read,\nthen this should be opened as a seperate bugzilla, since it makes no sense\nto continue in the context of this one.",
        "Looking at the files in IT #98736, there is zero evidence of\nthe multi-threaded/mincore/mmap interaction issue that is the\nsubject of this bugzilla.\n\nThe only relationship between the two situations is that something\nis causing a task's mmap_sem to be deadlocked, and subsequent ps commands\nhang when trying to take the semaphore.\n\nIn this bugzilla, it's Doug's program that forces simultaneous mincore()/mmap()\ninteraction between two threads of a process, and both threads end up blocking\non their own mmap_sem.  In #IT 98736, it's something completely different,\nand that problem is what needs to be determined.\n\nIt makes no sense to tie that IT to this bugzilla; it needs its own bugzilla.",
        "> The first comment in this bug don't talk about an IT item. What about fixing\n> that problem report and leaving any IT by side?Doug Chapman (the reporter) was well on his way to fixing this with his\nfirst patch.  Perhaps he can resurrect his work and post an updated\nversion?",
        "Doug's final patch:http://post-office.corp.redhat.com/archives/rhkernel-list/2006-September/msg00540.html",
        "Has this patch been proposed for upstream inclusion?",
        "(In reply tocomment #21)> Has this patch been proposed for upstream inclusion?\n>I have not proposed it upstream as I wasn't sure what the procedure was for\nsensitive patches.  I sent it to rhkernel-list to get ack's but received none\n(no nacks either however).",
        "This bug is 10 month old and I would propose we make it public now and propose\nthe patch upstream. This one is a good candidate for the next RHEL4 async errata\nand we should go with a patch that is acceptable by upstream. Any objections?",
        "So no objections to lifting the embargo. I will communicate this through\nvendor-sec and then open this Bugzilla.",
        "And it seems this is not only ia64. Is 64-bit specific or can it also happen on\n32-bit architectures?",
        "Doug Chapman wrote:> How reproducible:\n> All the time (on ia64 SMP however I expect this is not arch dependent)> I can easily reproduce this on my ia64 hardware.  I do not expect it to be\n> hardware specific however (but I will verify when I get access to other\n> hardware).",
        "Createdattachment 143802[details]Proposed patch from Andrew Morton",
        "Createdattachment 143803[details]Additional patch on-top of the previous one",
        "Hi Doug,\n\nJust in case you can't see private comments, I've un-privatized the\nlast two from Andrew Morton.  Can you apply his cleanups/fixes to \nyour patch, verify it, and re-post to RHKL?\n\nThanks,\n  Dave",
        "looks like Linux re-worked this himself, please see:http://marc.theaimsgroup.com/?l=git-commits-head&m=116629555506940&w=2http://marc.theaimsgroup.com/?l=git-commits-head&m=116638195203710&w=2http://marc.theaimsgroup.com/?l=git-commits-head&m=116638195213406&w=2",
        "(In reply tocomment #30)> looks like Linux re-worked this himself, please see:\n> \n>http://marc.theaimsgroup.com/?l=git-commits-head&m=116629555506940&w=2>http://marc.theaimsgroup.com/?l=git-commits-head&m=116638195203710&w=2>http://marc.theaimsgroup.com/?l=git-commits-head&m=116638195213406&w=2Hi Doug,\n\nJason meant \"Linus\", who re-worked your patch himself.\nCan you apply Linus' patch, test it on your ia64, and\nre-post to RHKL?\n\nThanks,\n  Dave",
        "patch posted to rhkernel-list for review.",
        "committed in stream U5 build 42.37. A test kernel with this patch is available\nfromhttp://people.redhat.com/~jbaron/rhel4/",
        "I have verified this in 2.6.9-42.37.EL.",
        "fix looks good in 42.0.6",
        "An advisory has been issued which should help the problem\ndescribed in this bug report. This report is therefore being\nclosed with a resolution of ERRATA. For more information\non the solution and/or where to find the updated files,\nplease follow the link below. You may reopen this bug report\nif the solution does not work for you.http://rhn.redhat.com/errata/RHSA-2007-0014.html"
    ]
}