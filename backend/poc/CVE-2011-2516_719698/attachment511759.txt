// This program is used to reproduce a bug in Apache Santuario.
// Compile it and run with valgrind to see the error messages.

// Warning: this program exploits a library bug and might cause any kind of
// behavior, including data loss, exploding your computer or the appearance of
// Santa Claus.

#include <iostream>

#ifdef unix
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#endif

#include <xercesc/parsers/XercesDOMParser.hpp>
#include <xercesc/util/PlatformUtils.hpp>

#include <xsec/dsig/DSIGReference.hpp>
#include <xsec/enc/OpenSSL/OpenSSLCryptoKeyRSA.hpp>
#include <xsec/framework/XSECException.hpp>
#include <xsec/framework/XSECProvider.hpp>

#include <openssl/rand.h>
#include <openssl/pem.h>

XERCES_CPP_NAMESPACE_USE

void init_libs() {
    try {
        XMLPlatformUtils::Initialize();
        XSECPlatformUtils::Initialise();
    } catch (...) {
        std::cerr << "Error initializing Xerces/XSec\n";
        exit(EXIT_FAILURE);
    }
}

void finish_libs() {
    try {
        XSECPlatformUtils::Terminate();
        XMLPlatformUtils::Terminate();
    } catch (...) {
        std::cerr << "Error finishing Xerces/XSec\n";
        exit(EXIT_FAILURE);
    }
}

bool fileExists(const char *file) {
#ifdef unix
    struct stat statBuffer;
    return (stat(file, &statBuffer) == 0);
#else
#error fileExists() not implemented for this system
#endif
}

void signXmlFile(DOMDocument *doc) {
    std::cout << "Signing XML file\n";

    XSECProvider prov;
    DSIGSignature *sig = prov.newSignature();
    sig->setDSIGNSPrefix(MAKE_UNICODE_STRING("ds"));

    DOMElement *sigNode = sig->createBlankSignature(doc, CANON_C14N_COM,
                                                    SIGNATURE_RSA, HASH_SHA1);

    DOMElement *rootElem = doc->getDocumentElement();
    rootElem->appendChild(sigNode);

    DSIGReference *ref = sig->createReference(MAKE_UNICODE_STRING(""));
    ref->appendEnvelopedSignatureTransform();

    BIO *bio = BIO_new_file("rsa-private.pem", "r");
    assert(bio);
    EVP_PKEY *private_key = PEM_read_bio_PrivateKey(bio, NULL, NULL, NULL);
    assert(private_key);
    OpenSSLCryptoKeyRSA *rsakey = new OpenSSLCryptoKeyRSA(private_key);

    sig->setSigningKey(rsakey);
    sig->sign();

    EVP_PKEY_free(private_key);
    BIO_free_all(bio);
}

void verifyXmlFile(DOMDocument *doc)
{
    std::cout << "Verifying XML file\n";

    XSECProvider prov;
    DSIGSignature *sig = prov.newSignatureFromDOM(doc);

    sig->load();

    BIO *bio = BIO_new_file("rsa-public.pem", "r");
    assert(bio);
    EVP_PKEY *public_key = PEM_read_bio_PUBKEY(bio, NULL, NULL, NULL);
    assert(public_key);
    OpenSSLCryptoKeyRSA *rsakey = new OpenSSLCryptoKeyRSA(public_key);

    sig->setSigningKey(rsakey);

    std::cout << "sig->verify() == " << sig->verify() << "\n";

    EVP_PKEY_free(public_key);
    BIO_free_all(bio);
}

void saveXmlFile(DOMDocument *doc, const char *file)
{
    XMLCh *xmlstr_file = XMLString::transcode(file);

    DOMImplementation *impl = DOMImplementationRegistry::getDOMImplementation(
                                MAKE_UNICODE_STRING("LS"));
    DOMLSSerializer *serializer =
        ((DOMImplementationLS*)impl)->createLSSerializer();

    serializer->writeToURI(doc, xmlstr_file);

    serializer->release();
    XMLString::release(&xmlstr_file);
}

int main() {
    init_libs();

    assert(fileExists("example.xml"));
    assert(fileExists("rsa-private.pem"));
    assert(fileExists("rsa-public.pem"));

    {
        try {
            XercesDOMParser parser;
            parser.setValidationScheme(XercesDOMParser::Val_Auto);
            parser.setDoNamespaces(true);

            parser.parse("example.xml");
            DOMDocument *doc = parser.getDocument();

            signXmlFile(doc);
            saveXmlFile(doc, "result.xml");
            verifyXmlFile(doc);

        } catch (XMLException& e) {
            char *msg = XMLString::transcode(e.getMessage());
            std::cerr << "XMLException: " << msg << "\n";
            XMLString::release(&msg);
        } catch (DOMException& e) {
            char *msg = XMLString::transcode(e.getMessage());
            std::cerr << "DOMException: " << msg << "\n";
            XMLString::release(&msg);
        } catch (XSECException& e) {
            char *msg = XMLString::transcode(e.getMsg());
            std::cerr << "XSECException: " << msg << "\n";
            XMLString::release(&msg);
        }
    }

    finish_libs();
    return 0;
}
