{
    "bugid": "1099235",
    "cveid": [
        "CVE-2015-5277"
    ],
    "summary": "CVE-2015-5277 glibc: nss_files doesn't detect ERANGE problems correctly [rhel-7.3]",
    "alias": "None",
    "product": "Red Hat Enterprise Linux 7",
    "hardware": "Unspecified",
    "os": "Unspecified",
    "url": "",
    "reported_date": "2014-05-19 21:08 UTC byNalin Dahyabhai",
    "attachment": [
        "https://bugzilla-attachments.redhat.com/attachment.cgi?id=897322"
    ],
    "comment": [
        "Createdattachment 897322[details]Test program, takes optional user name (\"root\") and initial buffer size (4) as arguments\n\nDescription of problem:\nIn glibc-2.17-c758a686/nss/nss_files/files-XXX.c, in get_contents(), the loop appears to be checking for a too-small passed-in buffer incorrectly, in that it assigns 0xff to the final byte in the buffer after passing the buffer to fgets_unlocked instead of before.\n\nVersion-Release number of selected component (if applicable):\nglibc-2.17-55.el7.x86_64\n\nHow reproducible:\nAlways\n\nSteps to Reproduce:\n1. Call getpwnam_r() with bufsize set to a small number (4 in my test).\n\nActual results:\ngetpwnam_r() returns 0\n\nExpected results:\ngetpwnam_r() returns ERANGE",
        "This is not reproducible on F21, so we probably have a patch for this already; it's just a matter of bisecting it.  From a quick look, the following commit may have fixed this as a side-effect.\n\ncommit 977f4b31b7ca4a4e498c397f3fd70510694bbd86\nAuthor: Siddhesh Poyarekar <siddhesh>\nDate:   Wed Oct 30 16:13:37 2013 +0530\n\n    Fix reads for sizes larger than INT_MAX in AF_INET lookup\n    \n    Currently for AF_INET lookups from the hosts file, buffer sizes larger\n    than INT_MAX silently overflow and may result in access beyond bounds\n    of a buffer.  This happens when the number of results in an AF_INET\n    lookup in /etc/hosts are very large.\n    \n    There are two aspects to the problem.  One problem is that the size\n    computed from the buffer size is stored into an int, which results in\n    overflow for large sizes.  Additionally, even if this size was\n    expanded, the function used to read content into the buffer (fgets)\n    accepts only int sizes.  As a result, the fix is to have a function\n    wrap around fgets that calls it multiple times with int sizes if\n    necessary.",
        "(In reply to Siddhesh Poyarekar fromcomment #3)> This is not reproducible on F21, so we probably have a patch for this\n> already; it's just a matter of bisecting it.  From a quick look, the\n> following commit may have fixed this as a side-effect.It's not that simple.  I spent some time last week trying to bisect the issue from upstream code and I couldn't.  Everything right down to 2.17 seems to work correctly when in F21 and that sounds wrong.  I'm going to try this again, this time on a rhel-7 box.",
        "... and we have a winner, it is:https://sourceware.org/bugzilla/show_bug.cgi?id=17079which was fixed by:\n\ncommit ac60763eac3d43b7234dd21286ad3ec3f17957fc\nAuthor: Andreas Schwab <schwab>\nDate:   Mon Jun 23 10:24:45 2014 +0200\n\n    Don't ignore too long lines in nss_files (BZ #17079)\n\nI broke it in rhel-7.0 when I backported the buggy patch.",
        "Since the problem described in this bug report should be\nresolved in a recent advisory, it has been closed with a\nresolution of ERRATA.\n\nFor information on the advisory, and where to find the updated\nfiles, follow the link below.\n\nIf the solution does not work for you, open a new bug report.https://rhn.redhat.com/errata/RHSA-2016-2573.html"
    ]
}