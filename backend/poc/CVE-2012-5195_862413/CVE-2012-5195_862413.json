{
    "bugid": "862413",
    "cveid": [
        "CVE-2012-5195"
    ],
    "summary": "CVE-2012-5195 perl: heap buffer overrun flaw may lead to arbitrary code execution",
    "alias": "CVE-2012-5195",
    "product": "Security Response",
    "hardware": "All",
    "os": "Linux",
    "url": "",
    "reported_date": "2012-10-02 20:02 UTC byVincent Danen",
    "attachment": [
        "https://bugzilla-attachments.redhat.com/attachment.cgi?id=624012"
    ],
    "comment": [
        "The following flaw was reported in perl versions prior to 5.15.5 in conjunction with glibc versions prior to 2.16:\n\nThe Perl programming language has a string repeat operator, 'x'. For\nexample, the expression (\"ab-\" x 4) evaluates to \"ab-ab-ab-ab-\". In the\ncase where the string on the LHS is a single character long, and where the\ncount on the right is greater than 2Gb, a truncation / sign-extension\nissue on older perls will cause the memory needed for the new string to be\nallocated correctly, but the code that fills that buffer with copies of\nthe original character may loop past the end of the buffer, probably\ncontinuing until an unmapped memory region is reached and a SEGV occurs.\nIt may be possible to adjust the count so that the buffer is overrun, but\nthe SEGV isn't reached.\n\nThe buffer is filled using the C library's memset() function; in versions\nof glibc before 2.16, it didn't check for a negative count, and this could\ncause it to access a negative offset in a jump table, and possibly jump\ninto arbitrary code.\n\nNote that perl code is only vulnerable where the attacker can control the\ncount argument of the repeat operator; such poorly-written code is already\nsusceptible to a denial-of-service attack; the flaws in older perls and\nglibc escalate this into buffer overruns and possible arbitrary code\nexecution.\n\nThis patch addresses the issue:> diff --git a/util.c b/util.c\n> index 0ea39c6..110da99 100644\n> --- a/util.c\n> +++ b/util.c\n> @@ -3319,6 +3319,8 @@ Perl_repeatcpy(register char *to, register const char   *from, I32 len, register I\n>  {\n>      PERL_ARGS_ASSERT_REPEATCPY;>> +    if (count < 0)\n> +     Perl_croak_nocontext(\"%s\",PL_memory_wrap);\n>      if (len == 1)\n>       memset(to, *from, count);\n>      else if (count) {>",
        "Can you test it?\n\nI give a try on x86_64 Fedora 17 with perl 5.14.2 and glibc-2.15-57.fc17. Unfortunately I have 4 GB of physical memory only.\n\n$ perl -e '$a = q{a} x 2**31+0;'\n\nconsumes more than 2 GB however it swaps a lot.\n\n$ perl -e '$a = q{a} x 2**31+1;'\n\nterminates quickly.\n\nDebugger shows both `count' variable in perl:Perl_repeatcpy() and `__len' variable in glibc:memset() are 8 bytes long, so no trim should happen.\n\nHowever I do not understand why 2**31+1 is so fast. Like the counter was wrapped somewhere underneath in the glibc. Unfortunately memset() cannot report any error. It should return its first argument always.",
        "I see why I cannot reproduce it with x86_64 Fedora. Perbug #720610, we have applied patch making the Perl_repeatcpy() safe for repeat counter > 2^31 by changing the function prototype. Thus the count argument is never wrapped.\n\nThe patch lives in Fedora since release 14 (perl 5.12.4). The patch is part of upstream since perl 5.16.0.\n\nHowever the reason why 2**32+1 finished quickly is not clear for me yet.",
        "(In reply tocomment #0)> \n> The buffer is filled using the C library's memset() function; in versions\n> of glibc before 2.16, it didn't check for a negative countHow can glibc check for negative count, if the count argument is of type size_t which is unsigned by definition?",
        "I've asked upstream for further details yesterday, but they have not yet responded.  Have you tried with a 32bit system?  I'll give this a go this afternoon on some 32bit virtual machines (with smaller amounts of RAM) to see if it can be reproduced.\n\nI am also unsure of the correlation with glibc; we may need someone more familiar with glibc to check why this is the case.  Perhaps Jeff can enlighten us?",
        "In response to c#4, it could check for the high bit set on the count.  That would indicate a \"negative\" value if the value was interpreted as a signed value.  However, I think that returning an error or not performing the memset would be a standards violation.\n\nNote that glibc's memset did have a bug in which it was doing signed comparisons of the size argument when it should have been doing unsigned comparisons.  This could result in an incorrect index being computed for the jumptable and jumping to a unexpected location.  This bug was fixed by the following commit:\n\ncommit e80d6f94e19d17b91e3cd3ada7193cc88f621feb\nAuthor: Michael Matz <matz>\nDate:   Thu Apr 5 10:48:14 2012 +0200\n\n    Fix size parameter comparisions.\n    \n    [BZ #13592]\n    There are several signed compares of the size argument, whereas\n    it really is unsigned.  Depending on situations e.g. a \"memset(ptr, 0,\n    -1)\" segfault (but for the wrong reasons, because jumping into nirvana)\n    or succeeds even.\n    \n    In normal use this is harmless, as a size with signbit set indicates\n    more than half the address space which on x86_64 is impossible to\n    allocate, but as the size is used to index some jump tables this\n    potentially could have other unwanted side effects.",
        "(In reply tocomment #5)> Have you tried with a 32bit system?No.",
        "(In reply tocomment #6)> Note that glibc's memset did have a bug in which it was doing signed\n> comparisons of the size argument when it should have been doing unsigned\n> comparisons.  This could result in an incorrect index being computed for the\n> jumptable and jumping to a unexpected location.  This bug was fixed by the\n> following commit:Jeff, did glibc always have this bug?  Or do we know when, or in what version, it may have been introduced?",
        "Upstream it appears to have been introduced in glibc-2.7, circa late 2007 or early 2008.  It looks like the buggy code was backported into RHEL 5.\n\nThe fixes went into F18.\n\nSo RHEL 5 & 6 and Fedora 16 & 17 have this glibc bug.\n\njeff",
        "I'd say there are two problems:\n\n(1) glibc mishandles memset() count argument. This should be fixed in glibc.\n\n(2) perl can pass count value to memset() not fitting into size_t type. This should be fixed in perl.\n\nNow the perl issue. We have again two problems:\n\n(2a) Perl_repeatcpy() count argument is of type I32 but the function is called from various places with variables of bigger type, IV, and thus the value can be clamped.\n\nThis is issue on RHEL only as Fedora has changed the prototype already (therefore I think upstream will not comment Fedora builds). Also this is problem on x86_64 where IV is bigger than I32 for sure. Whereas this might not be issue on x86 (but I'm not sure about the actual size of IV on the platform).\n\nUnfortunately we cannot apply the Fedora patch to RHEL because it changes prototype of public Perl_repeatcpy() which would break ABI. However I think the breakage would not be so serious because we know about only one another piece of software on CPAN calling this function, so I doubt the function is used by anybody else.\n\nThis is not problem on x86 because you cannot allocate more than 2**32 there.\nThis is problem on x86_64.\n\nWe could find all Perl_repeatcpy() calls from perl and guard them with a condition.\n\n(2b) Perl_repeatcpy() passes I32/IV on RHEL/Fedora to memset(). This can be problem on platforms where sizeof(IV) > sizof(size_t) for value overrun and this is definitely problem when negative value is passed because I32/IV are signed.\n\nThis can be fixed easily by adding check for negative value into  Perl_repeatcpy() as shown incomment #1.",
        "Createdattachment 624012[details]memset wrapper\n\nThis is wrapper for libc memset(). It prints arguments and checks whether the memory has been set by libc memset() properly. It aborts in case of an error.\n\nCompile as\n\n$(CC) -Wall --std=c99 $< --shared -DPIC -fPIC -o $@ -ldl\n\nand the LD_PRELOAD the shared library.",
        "* RHEL-5 perl-5.8.8:\n\nPerl_repeatcpy() does not call memset. The count argument is of type I32. It's called from 3 places:\n\npp.c:1472:\n  count passed as IV. Guarded by \"if (count > 1)\" on line 1440 already.\npp.c:1498:\n  count passed as IV. Guarded by \"if (count < 1) {} else\" on line 1490 already.\nregcomp.c:1302:\n  count passed as I32. Guarded by \"if (mincount > 1)\" on line 1300 already.\n\nResolution: We need to check for count > 2<<(sizeof(I32)-1) at the three places and croak before.\n\n\n* RHEL-6 perl-5.10.1:\n\nPerl_repeatcpy() does not call memset. The count argument is of type I32. It's called from 3 places:\n\npp.c:1556:\n  The same as perl-5.8.8.\npp.c:1582:\n  The same as perl-5.8.8.\nregcomp.c:3357:\n  The same as perl-5.8.8.\n\nResolution: We need to check for count > 2<<(sizeof(I32)-1) at the three places and croak before.\n\n\n* Fedora <= 17 perl-5.14.2:\n\nPerl_repeatcpy() calls memset. The count argument is of type IV. It's called from 3 places:\n\npp.c:1786:\n  Already guarded by \"if (count > 1)\" on line 1754.\npp.c:1813:\n  Already guarded by \"if (count < 1) {} else\" on line 1805.\nregcomp.c:3640:\n  Already guarded by \"if (mincount > 1)\" on line 3638.\n\nResolution: We need to check for count > SIZE_MAX in Perl_repeatcpy() and croak before. We can add check for negative value at the same place because Perl_repeatcpy() is public function.\n\n\n* Fedora >= 18 perl-5.16.1:\n\nPerl_repeatcpy() calls memset. The count argument is of type IV. It's called from 1 place:\n\nregcomp.c:3999:\n  Already guarded by \"if (mincount > 1): on line 3997.\n\nResolution: We need to check for count > SIZE_MAX in Perl_repeatcpy() and croak before. We can add check for negative value at the same place because Perl_repeatcpy() is public function.",
        "Correction to RHEL: We need to add the checks only at places where IV is passed as I32. That means only to the first two places.",
        "(In reply tocomment #2)> Can you test it?\n> \n> I give a try on x86_64 Fedora 17 with perl 5.14.2 and glibc-2.15-57.fc17.\n> Unfortunately I have 4 GB of physical memory only.\n> \n> $ perl -e '$a = q{a} x 2**31+0;'\n> \n> consumes more than 2 GB however it swaps a lot.\n> \n> $ perl -e '$a = q{a} x 2**31+1;'\n>Important notice to the reproducer: Correct notation is `q{a} x (2**31+1)'. Without the parenthesis, the part after the exponent is ignored.\n\nWith this I can see in debugger on RHEL-6 the IV-to-I32 overflow:\n\n(gdb) set args -e '$a = q{a} x (2**31+1);'\n(gdb) run\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\n\nStarting program: /home/test/rhel/perl/perl-5.10.1/perl -e '$a = q{a} x (2**31+1);'\n[Thread debugging using libthread_db enabled]\n\nBreakpoint 1, Perl_repeatcpy (my_perl=0x602010, to=0x7fff7093b011 \"\", \n    from=0x7fff7093b010 \"a\", len=1, count=-2147483648) at util.c:3078\n3078        if (len == 1) {",
        "Createdattachment 624190[details]Proposed fix for perl-5.10.1\n\nThis checks for IV-to-I32 wrap when calling Perl_repeatcpy(). It does not need to check for negative values because they are checked on other places. It's not necessary to do checks inside the function because it does not pass the value to memset() and it operates on negative values correctly.",
        "The 5.10.1 patch applies and fixes this bug in RHEL-5 perl-5.8.8 too. Verified with gdb as described incomment #19.",
        "If you install perl(Inline::C), you can see on Fedora 17, that negative count argument dooms the memory:\n\n$ LD_PRELOAD=~/perl/repeatcpy-CVE-2012-5195/memset.so perl -e 'use Inline C => q/void test(){ char *p = malloc(1); Perl_repeatcpy(p, \"a\", 1, -1);}/; test();'\n[...]\nCalled: memset(source=0x2172120, value=0, count=48)\nCalled: memset(source=0x22843b0, value=97, count=18446744073709551615)\nmemset() did not set byte at offset 0 (0x22843b0[0]=144 != 97)!\nNe\u00fasp\u011b\u0161n\u011b ukon\u010den (SIGABRT)\n\nIf you remove the memset checker and replace the count argument -1 to -42, you can get segfault:\n\n$ perl -e 'use Inline C => q/void test(){ char *p = malloc(1); Perl_repeatcpy(p, \"a\", 1, -42);}/; test();'\nNeopr\u00e1vn\u011bn\u00fd p\u0159\u00edstup do pam\u011bti (SIGSEGV)\n\nI can rewrite the test to XS (because Inline::C is clumsy as it calls GCC), but I don't think it's valuable.\n\nActually calling Perl_repeatcpy with argument mismatching length of allocated buffer passed as first argument violates API. And because SIZE_MAX > IV_MAX, I think there is nothing to fix in Fedora. (Well, some platforms could have the condition false, like PPC32, but I have not machine to check it.)\n\nSo I tend to mark Fedora as unaffected.",
        "Createdattachment 624842[details]Upstream fix for perl-5.12 and 5.14\n\nUpstream has just pushed this commit identical to code fromcomment #1into 5.12 and 5.14 branches only.",
        "Upstream commit:http://perl5.git.perl.org/perl.git/commit/b675304e3fdbcce3ef853b06b6ebe870d99faa7e",
        "Createdattachment 704824[details]Amendment for 5.10\n\nThis patch is needed to prevent from silent data corruption on i686.",
        "RHEL-6 already fixed in perl-5.10.1-129.el6 asbug #720644.",
        "5.10 patches are applicable to 5.8.8.",
        "Acknowledgements:\n\nRed Hat would like to thank the Perl project for reporting this issue.  Upstream acknowledges Tim Brown as the original reporter.",
        "This issue has been addressed in following products:\n\n  Red Hat Enterprise Linux 5\n  Red Hat Enterprise Linux 6\n\nVia RHSA-2013:0685https://rhn.redhat.com/errata/RHSA-2013-0685.html"
    ]
}