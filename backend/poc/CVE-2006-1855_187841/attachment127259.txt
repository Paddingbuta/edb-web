
Details:

The bug arises from the following two code snippets:

<snip>
static inline void choose_new_parent(task_t *p, task_t *reaper, task_t 
*child_reaper)
{
     /*
      * Make sure we're not reparenting to ourselves and that
      * the parent is not a zombie.
      */
     BUG_ON(p == reaper || reaper->state >= EXIT_ZOMBIE || 
reaper->exit_state >= EXIT_ZOMBIE);
     p->real_parent = reaper;
     if (p->parent == p->real_parent)
         BUG();
}
</snip>

and

<snip>
static inline void forget_original_parent(struct task_struct * father,
                       struct list_head *to_release)
{
     struct task_struct *p, *reaper = father;
     struct list_head *_p, *_n;

     do {
         reaper = next_thread(reaper);
         if (reaper == father) {
             reaper = child_reaper;
             break;
         }
     } while (reaper->exit_state >= EXIT_ZOMBIE);
</snip>

forget_original_parent() is called when a process is dying; it finds a 
new parent for all the child processes of the dying process.  The 
problem arises in the selection of the new parent process.  The 
comparison between real_parent and parent in choose_new_parent--if 
true--will trigger a kernel panic. This is apparently left-over 
debugging code that is stripped out in 2.6.11.12.

Consider the following scenario:

Process A calls fork() to create process C. Process A then uses 
pthread_create() to initiate a seperate thread of execution within its 
process space; call this thread B.  B uses ptrace() to attach itself to 
process C. Process A then terminates.  At this point, A is the 
real_parent for process C, but B is its parent (when a process or thread 
attaches to another with ptrace, it becomes its parent but not its 
real_parent).

When A terminates, forget_original_parent iterates through all of its 
children and all of its ptrace_children, where ptrace_children is a list 
of processes that A created but were taken away by some other process in 
a PTRACE_ATTACH operation.  A tries to find an appropriate process in 
its thread group to assume responsibility for its poor orphaned 
children, falling back on init as a last resort. Because B is a peer of 
A in A's thread group (despite the fact that A created B), B is a 
candidate for this status. When choose_new_thread() is called, however, 
the comparison determines that the reaper and the existing parent are 
one in the same, and the kernel panics.

This all boils down to a residual debugging statement that has been 
hanging around in the kernel for some time; it was only exposed after 
2.6.9 because of a change made in the way reapers were selected that 
allowed for other threads besides the group leader thread to assume 
control of child processes.

Here is sample code that demonstrates the problem:

#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/ptrace.h>
#include <signal.h>
#include <sys/syscall.h>

#if !defined(SYS_gettid)
 #define SYS_gettid 224
#endif

int gettid()
{
   return syscall((long int) SYS_gettid);
}

pthread_t b;
pid_t c;

void * b_func(void *arg)
{
   int ret, status;

   fprintf(stderr, "thread %d: attaching to process %d\n",
   gettid(),c);

   ret = ptrace(PTRACE_ATTACH, c, NULL, NULL);
   if(ret != 0)
   {
      perror("PTRACE_ATTACH failed");
      abort();
   }

   waitpid(c, &status, __WALL | WUNTRACED);

   fprintf(stderr, " thread %d: contining process %d\n", gettid(), c);
   ret = ptrace(PTRACE_CONT, c, NULL, NULL);
   if(ret != 0)
   {
      perror("PTRACE_CONT failed");
      abort();
   }

   while(1) sleep(1);
}

void c_func()
{
   fprintf(stderr, "child process %d initiated, traced, and spinning.\n",gettid());
   while(1)
   {
      //fprintf(stderr, "child process %d spinning...\n",gettid());
      sleep(1);
   }
}

int main(int argc, char**argv)
{
   fprintf(stderr, "main is %d\n",gettid());
    c = fork();

   if(!c)
   {
     c_func();
     exit(0);
   }

   // give it a chance to show up
   sleep(1);

   fprintf(stderr, "creating ptrace handler thread\n");
   pthread_create(&b,NULL,b_func,NULL);

    fprintf(stderr, "main sleeping for 5 seconds then panicing kernel\n");

    sleep(5);

   exit(0);
}
