Index: ldapserver/ldap/servers/plugins/replication/repl5_total.c
===================================================================
RCS file: /cvs/dirsec/ldapserver/ldap/servers/plugins/replication/repl5_total.c,v
retrieving revision 1.5
diff -u -8 -r1.5 repl5_total.c
--- ldapserver/ldap/servers/plugins/replication/repl5_total.c	19 Apr 2005 22:07:32 -0000	1.5
+++ ldapserver/ldap/servers/plugins/replication/repl5_total.c	27 Jan 2006 16:35:49 -0000
@@ -580,17 +580,17 @@
 my_ber_scanf_attr (BerElement *ber, Slapi_Attr **attr, PRBool *deleted)
 {
     char *attrtype = NULL;
 	CSN *attr_deletion_csn = NULL;
     PRBool val_deleted;
     char *lasti;
     unsigned long len;
 	unsigned long tag;
-    char *str;
+    char *str = NULL;
     int rc;
     Slapi_Value *value;
 
     PR_ASSERT (ber && attr && deleted);
 
     /* allocate the attribute */
     *attr = slapi_attr_new ();
     if (attr == NULL)
@@ -680,16 +680,19 @@
 
     return 0;
 loser:
     if (*attr)
         slapi_attr_free (attr);
     if (value)
         slapi_value_free (&value);
 
+    slapi_ch_free ((void **)&attrtype);
+    slapi_ch_free((void **)&str);
+
     return -1;    
 }
 
 /*
  * Extract the payload from a total update extended operation,
  * decode it, and produce a Slapi_Entry structure representing a new
  * entry to be added to the local database.
  */
Index: ldapserver/ldap/servers/plugins/replication/repl_controls.c
===================================================================
RCS file: /cvs/dirsec/ldapserver/ldap/servers/plugins/replication/repl_controls.c,v
retrieving revision 1.5
diff -u -8 -r1.5 repl_controls.c
--- ldapserver/ldap/servers/plugins/replication/repl_controls.c	19 Apr 2005 22:07:32 -0000	1.5
+++ ldapserver/ldap/servers/plugins/replication/repl_controls.c	27 Jan 2006 16:35:49 -0000
@@ -344,25 +344,25 @@
     	    char *emlast;
     	    BerElement *ember = ber_init( embvp );
     	    if ( ember != NULL )
     		{
         		for ( emtag = ber_first_element( ember, &emlen, &emlast );
         		      emtag != LBER_ERROR && emtag != LBER_END_OF_SEQORSET;
         		      emtag = ber_next_element( ember, &emlen, emlast ))
 			    {
-        		    struct berval **embvals;
-        		    if ( ber_scanf( ember, "{i{a[V]}}", &op, &type, &embvals ) == LBER_ERROR )
+        		    struct berval **embvals = NULL;
+        		    type = NULL;
+        		    if ( ber_scanf( ember, "{i{a[V]}}", &op, &type, &embvals ) != LBER_ERROR )
 					{
-            			continue;
+        				slapi_mods_add_modbvps( smods, op, type, embvals);
 					/* GGOODREPL I suspect this will cause two sets of lastmods attr values
 						to end up in the entry. We need to remove the old ones.
 					*/
         		    }
-                    slapi_mods_add_modbvps( smods, op, type, embvals);
         		    free( type );
         		    ber_bvecfree( embvals );
         		}
     	    }
     	    ber_free( ember, 1 );
     	}
     }
 }
Index: ldapserver/ldap/servers/plugins/replication/repl_extop.c
===================================================================
RCS file: /cvs/dirsec/ldapserver/ldap/servers/plugins/replication/repl_extop.c,v
retrieving revision 1.7
diff -u -8 -r1.7 repl_extop.c
--- ldapserver/ldap/servers/plugins/replication/repl_extop.c	19 Apr 2005 22:07:32 -0000	1.7
+++ ldapserver/ldap/servers/plugins/replication/repl_extop.c	27 Jan 2006 16:35:50 -0000
@@ -379,17 +379,17 @@
 free_and_return:
 	if (-1 == rc)
 	{
 		/* Free everything when error encountered */
  
 		/* slapi_ch_free accepts NULL pointer */
 		slapi_ch_free ((void**)protocol_oid);
 		slapi_ch_free ((void**)repl_root);
-		slapi_ch_free ((void **)extra_referrals);
+		slapi_ch_array_free (*extra_referrals);
 		slapi_ch_free ((void**)csnstr);
 
 		if (*supplier_ruv)
 		{
 			ruv_destroy (supplier_ruv);
 		}
 
 	}
Index: ldapserver/ldap/servers/slapd/add.c
===================================================================
RCS file: /cvs/dirsec/ldapserver/ldap/servers/slapd/add.c,v
retrieving revision 1.5
diff -u -8 -r1.5 add.c
--- ldapserver/ldap/servers/slapd/add.c	19 Apr 2005 22:07:36 -0000	1.5
+++ ldapserver/ldap/servers/slapd/add.c	27 Jan 2006 16:35:51 -0000
@@ -97,18 +97,19 @@
 	 *		attrs	SEQUENCE OF SEQUENCE {
 	 *			type	AttributeType,
 	 *			values	SET OF AttributeValue
 	 *		}
 	 *	}
 	 */
 	/* get the name */
 	{
-    	char *dn;
+    	char *dn = NULL;
     	if ( ber_scanf( ber, "{a", &dn ) == LBER_ERROR ) {
+            slapi_ch_free_string(&dn);
     		LDAPDebug( LDAP_DEBUG_ANY,
     		    "ber_scanf failed (op=Add; params=DN)\n", 0, 0, 0 );
 			op_shared_log_error_access (pb, "ADD", "???", "decoding error");
     		send_ldap_result( pb, LDAP_PROTOCOL_ERROR, NULL,
     		    "decoding error", 0, NULL );
     		return;
     	}
     	e = slapi_entry_alloc();
@@ -116,40 +117,42 @@
     }
 	LDAPDebug( LDAP_DEBUG_ARGS, "    do_add: dn (%s)\n", slapi_entry_get_dn_const(e), 0, 0 );
 
 	/* get the attrs */
 	for ( tag = ber_first_element( ber, &len, &last );
 	      tag != LBER_DEFAULT && tag != LBER_END_OF_SEQORSET;
 	      tag = ber_next_element( ber, &len, last ) ) {
 		char *type = NULL, *normtype = NULL;
-		struct berval	**vals;
+		struct berval	**vals = NULL;
 		if ( ber_scanf( ber, "{a{V}}", &type, &vals ) == LBER_ERROR ) {
 			op_shared_log_error_access (pb, "ADD", slapi_sdn_get_dn (slapi_entry_get_sdn_const(e)), "decoding error");
 			send_ldap_result( pb, LDAP_PROTOCOL_ERROR, NULL,
 			    "decoding error", 0, NULL );
+            slapi_ch_free_string(&type);
+            ber_bvecfree( vals );
 			goto free_and_return;
 		}
 
 		if ( vals == NULL ) {
 			LDAPDebug( LDAP_DEBUG_ANY, "no values for type %s\n", type, 0, 0 );
 			op_shared_log_error_access (pb, "ADD", slapi_sdn_get_dn (slapi_entry_get_sdn_const(e)), "null value");
 			send_ldap_result( pb, LDAP_PROTOCOL_ERROR, NULL, NULL,
 			    0, NULL );
-			free( type );			
+            slapi_ch_free_string(&type);
 			goto free_and_return;
 		}
 
 		normtype = slapi_attr_syntax_normalize(type);
 		if ( !normtype || !*normtype ) {
 			rc = LDAP_INVALID_SYNTAX;
 			PR_snprintf (ebuf, BUFSIZ, "invalid type '%s'", type);
 			op_shared_log_error_access (pb, "ADD", slapi_sdn_get_dn (slapi_entry_get_sdn_const(e)), ebuf);
 			send_ldap_result( pb, rc, NULL, ebuf, 0, NULL );
-			free( type );
+            slapi_ch_free_string(&type);
 			slapi_ch_free( (void**)&normtype );
 			ber_bvecfree( vals );
 			goto free_and_return;
 		}
 		free( type );
 	
        /* for now we just ignore attributes that client is not allowed
           to modify so not to break existing clients */
Index: ldapserver/ldap/servers/slapd/ava.c
===================================================================
RCS file: /cvs/dirsec/ldapserver/ldap/servers/slapd/ava.c,v
retrieving revision 1.4
diff -u -8 -r1.4 ava.c
--- ldapserver/ldap/servers/slapd/ava.c	19 Apr 2005 22:07:36 -0000	1.4
+++ ldapserver/ldap/servers/slapd/ava.c	27 Jan 2006 16:35:51 -0000
@@ -48,20 +48,22 @@
 static void strcpy_special_undo();
 
 int
 get_ava(
     BerElement	*ber,
     struct ava	*ava
 )
 {
-	char	*type;
+	char	*type = NULL;
 
 	if ( ber_scanf( ber, "{ao}", &type, &ava->ava_value )
 	    == LBER_ERROR ) {
+        slapi_ch_free_string(&type);
+        ava_done(ava);
 		LDAPDebug( LDAP_DEBUG_ANY, "  get_ava ber_scanf\n", 0, 0, 0 );
 		return( LDAP_PROTOCOL_ERROR );
 	}
 	ava->ava_type = slapi_attr_syntax_normalize(type);
 	free( type );
 
 	return( 0 );
 }
Index: ldapserver/ldap/servers/slapd/bind.c
===================================================================
RCS file: /cvs/dirsec/ldapserver/ldap/servers/slapd/bind.c,v
retrieving revision 1.6
diff -u -8 -r1.6 bind.c
--- ldapserver/ldap/servers/slapd/bind.c	19 Apr 2005 22:07:36 -0000	1.6
+++ ldapserver/ldap/servers/slapd/bind.c	27 Jan 2006 16:35:51 -0000
@@ -106,17 +106,17 @@
 do_bind( Slapi_PBlock *pb )
 {
     BerElement	*ber = pb->pb_op->o_ber;
     int		err, version = -1, method = -1, isroot;
     long 	long_method = -1;
     long ber_version = -1;
     int		auth_response_requested = 0;
     int		pw_response_requested = 0;
-    char		*dn, *saslmech = NULL;
+    char		*dn = NULL, *saslmech = NULL;
     struct berval	cred = {0};
     Slapi_Backend		*be = NULL;
     unsigned long rc;
     Slapi_DN sdn;
     Slapi_Entry *referral;
     char errorbuf[BUFSIZ];
     char **supported, **pmech;
     char authtypebuf[256]; /* >26 (strlen(SLAPD_AUTH_SASL)+SASL_MECHNAMEMAX+1) */
@@ -149,16 +149,17 @@
     version = ber_version;
     if ( rc == LBER_ERROR ) {
         LDAPDebug( LDAP_DEBUG_ANY,
                    "ber_scanf failed (op=Bind; params=Version,DN,Method)\n",
                    0, 0, 0 );
         log_bind_access (pb, "???", method, version, saslmech, "decoding error");
         send_ldap_result( pb, LDAP_PROTOCOL_ERROR, NULL,
                           "decoding error", 0, NULL );
+        slapi_ch_free_string(&dn);
         return;
     }
 
     slapi_sdn_init_dn_passin(&sdn,dn);
 
     LDAPDebug( LDAP_DEBUG_TRACE, "BIND dn=\"%s\" method=%d version=%d\n",
                dn, method, version );
 
Index: ldapserver/ldap/servers/slapd/compare.c
===================================================================
RCS file: /cvs/dirsec/ldapserver/ldap/servers/slapd/compare.c,v
retrieving revision 1.4
diff -u -8 -r1.4 compare.c
--- ldapserver/ldap/servers/slapd/compare.c	19 Apr 2005 22:07:36 -0000	1.4
+++ ldapserver/ldap/servers/slapd/compare.c	27 Jan 2006 16:35:52 -0000
@@ -55,62 +55,65 @@
 #include "slap.h"
 #include "pratom.h"
 
 
 void
 do_compare( Slapi_PBlock *pb )
 {
 	BerElement	*ber = pb->pb_op->o_ber;
-	char		*dn;
-	struct ava	ava;
+	char		*dn = NULL;
+	struct ava	ava = {0};
 	Slapi_Backend		*be = NULL;
 	int		err;
 	char		ebuf[ BUFSIZ ];
 	Slapi_DN sdn;
-	Slapi_Entry *referral;
+	Slapi_Entry *referral = NULL;
 	char errorbuf[BUFSIZ];
 
 	LDAPDebug( LDAP_DEBUG_TRACE, "do_compare\n", 0, 0, 0 );
 
 	/* count the compare request */
 	PR_AtomicIncrement(g_get_global_snmp_vars()->ops_tbl.dsCompareOps);
 
+    /* have to init this here so we can "done" it below if we short circuit */
+    slapi_sdn_init(&sdn);
+
 	/*
 	 * Parse the compare request.  It looks like this:
 	 *
 	 *	CompareRequest := [APPLICATION 14] SEQUENCE {
 	 *		entry	DistinguishedName,
 	 *		ava	SEQUENCE {
 	 *			type	AttributeType,
 	 *			value	AttributeValue
 	 *		}
 	 *	}
 	 */
 
-
 	if ( ber_scanf( ber, "{a{ao}}", &dn, &ava.ava_type,
 	    &ava.ava_value ) == LBER_ERROR ) {
 		LDAPDebug( LDAP_DEBUG_ANY,
 		    "ber_scanf failed (op=Compare; params=DN,Type,Value)\n",
 		    0, 0, 0 );
 		send_ldap_result( pb, LDAP_PROTOCOL_ERROR, NULL, NULL, 0,
 		    NULL );
-		return;
+		goto free_and_return;
 	}
 	/*
 	 * in LDAPv3 there can be optional control extensions on
 	 * the end of an LDAPMessage. we need to read them in and
 	 * pass them to the backend.
 	 */
 	if ( (err = get_ldapmessage_controls( pb, ber, NULL )) != 0 ) {
 		send_ldap_result( pb, err, NULL, NULL, 0, NULL );
 		goto free_and_return;
 	}
 	slapi_sdn_init_dn_passin(&sdn,dn);
+    dn = NULL; /* do not free - sdn owns it now */
 
 	/* target spec is used to decide which plugins are applicable for the operation */
 	operation_set_target_spec (pb->pb_op, &sdn);
 
 	LDAPDebug( LDAP_DEBUG_ARGS, "do_compare: dn (%s) attr (%s)\n",
 	    dn, ava.ava_type, 0 );
 
 	slapi_log_access( LDAP_DEBUG_STATS,
@@ -176,10 +179,11 @@
 		send_ldap_result( pb, LDAP_UNWILLING_TO_PERFORM, NULL,
 		    "Function not implemented", 0, NULL );
 	}
 
 free_and_return:;
 	if (be)
 		slapi_be_Unlock(be);
 	slapi_sdn_done(&sdn);
+    slapi_ch_free_string(&dn);
 	ava_done( &ava );
 }
Index: ldapserver/ldap/servers/slapd/delete.c
===================================================================
RCS file: /cvs/dirsec/ldapserver/ldap/servers/slapd/delete.c,v
retrieving revision 1.4
diff -u -8 -r1.4 delete.c
--- ldapserver/ldap/servers/slapd/delete.c	19 Apr 2005 22:07:36 -0000	1.4
+++ ldapserver/ldap/servers/slapd/delete.c	27 Jan 2006 16:35:52 -0000
@@ -61,17 +61,17 @@
 static void op_shared_delete (Slapi_PBlock *pb);
 
 /* This function is called to process operation that come over external connections */
 void
 do_delete( Slapi_PBlock *pb )
 {
 	Slapi_Operation *operation;
 	BerElement	*ber;
-	char	    *dn;
+	char	    *dn = NULL;
 	int			err;
 
 	LDAPDebug( LDAP_DEBUG_TRACE, "do_delete\n", 0, 0, 0 );
 	
 	slapi_pblock_get( pb, SLAPI_OPERATION, &operation);
 	ber = operation->o_ber;
 
 	/* count the delete request */
@@ -84,17 +84,17 @@
 	 */
 
 	if ( ber_scanf( pb->pb_op->o_ber, "a", &dn ) == LBER_ERROR ) {
 		LDAPDebug( LDAP_DEBUG_ANY,
 		    "ber_scanf failed (op=Delete; params=DN)\n", 0, 0, 0 );
 		op_shared_log_error_access (pb, "DEL", "???", "decoding error");
 		send_ldap_result( pb, LDAP_PROTOCOL_ERROR, NULL, NULL, 0,
 		    NULL );
-		return;
+		goto free_and_return;
 	}
 
 	/*
 	 * in LDAPv3 there can be optional control extensions on
 	 * the end of an LDAPMessage. we need to read them in and
 	 * pass them to the backend.
 	 */
 	if ( (err = get_ldapmessage_controls( pb, ber, NULL )) != 0 ) {
Index: ldapserver/ldap/servers/slapd/filter.c
===================================================================
RCS file: /cvs/dirsec/ldapserver/ldap/servers/slapd/filter.c,v
retrieving revision 1.5
diff -u -8 -r1.5 filter.c
--- ldapserver/ldap/servers/slapd/filter.c	19 Apr 2005 22:07:36 -0000	1.5
+++ ldapserver/ldap/servers/slapd/filter.c	27 Jan 2006 16:35:53 -0000
@@ -170,17 +170,17 @@
 static int
 get_filter_internal( Connection *conn, BerElement *ber, 
 	struct slapi_filter **filt, char **fstr, int maxdepth, int curdepth,
 	int *subentry_dont_rewrite, int *has_tombstone_filter )
 {
     unsigned long	len;
     int		err;
     struct slapi_filter	*f;
-    char		*ftmp, *type;
+    char		*ftmp, *type = NULL;
 
 	LDAPDebug( LDAP_DEBUG_FILTER, "=> get_filter_internal\n", 0, 0, 0 );
 
 	/*
 	 * Track and check the depth of nesting.  Use post-increment on
 	 * current depth here because this function is called for the
 	 * top-level filter (which does not count towards the maximum depth).
 	 */
@@ -288,16 +288,17 @@
 		if ( (err = get_ava( ber, &f->f_ava )) == 0 ) {
 		  *fstr=filter_escape_filter_value(f, FILTER_LE_FMT, FILTER_LE_LEN);
 		}
 		break;
 
 	case LDAP_FILTER_PRESENT:
 		LDAPDebug( LDAP_DEBUG_FILTER, "PRESENT\n", 0, 0, 0 );
 		if ( ber_scanf( ber, "a", &type ) == LBER_ERROR ) {
+            slapi_ch_free_string(&type);
 			err = LDAP_PROTOCOL_ERROR;
 		} else {
 			err = LDAP_SUCCESS;
 			f->f_type = slapi_attr_syntax_normalize( type );
 			free( type );
 			filter_compute_hash(f);
 			*fstr = slapi_ch_smprintf( "(%s=*)", f->f_type );
 		}
@@ -435,38 +436,41 @@
 get_substring_filter(
     Connection		*conn,
     BerElement		*ber,
     struct slapi_filter	*f,
     char		**fstr
 )
 {
 	unsigned long	tag, len, rc;
-	char		*val, *last, *type;
+	char		*val, *last, *type = NULL;
 	char		ebuf[BUFSIZ];
 
 	LDAPDebug( LDAP_DEBUG_FILTER, "=> get_substring_filter\n", 0, 0, 0 );
 
 	if ( ber_scanf( ber, "{a", &type ) == LBER_ERROR ) {
+        slapi_ch_free_string(&type);
 		return( LDAP_PROTOCOL_ERROR );
 	}
 	f->f_sub_type = slapi_attr_syntax_normalize( type );
 	free( type );
 	f->f_sub_initial = NULL;
 	f->f_sub_any = NULL;
 	f->f_sub_final = NULL;
 
 	*fstr = slapi_ch_malloc( strlen( f->f_sub_type ) + 3 );
 	sprintf( *fstr, "(%s=", f->f_sub_type );
 	for ( tag = ber_first_element( ber, &len, &last );
 	    tag != LBER_ERROR && tag != LBER_END_OF_SEQORSET;
 	    tag = ber_next_element( ber, &len, last ) )
 	{
+        val = NULL;
 		rc = ber_scanf( ber, "a", &val );
 		if ( rc == LBER_ERROR ) {
+            slapi_ch_free_string(&val);
 			return( LDAP_PROTOCOL_ERROR );
 		}
 		if ( val == NULL || *val == '\0' ) {
 			if ( val != NULL ) {
 				free( val );
 			}
 			return( LDAP_INVALID_SYNTAX );
 		}
@@ -568,18 +572,19 @@
 			break;
 		case LDAP_TAG_MRA_TYPE:
 			if ( gotelem != 0 ) {
 				if ( gotelem != 1 || gotoid != 1 ) {
 					goto parsing_error;
 				}
 			}
 			{
-			    char* type;
+			    char* type = NULL;
 			    if (ber_scanf( ber, "a", &type ) == LBER_ERROR) {
+				slapi_ch_free_string (&type);
 				rc = LDAP_PROTOCOL_ERROR;
 			    } else {
 				mrf->mrf_type = slapi_attr_syntax_normalize(type);
 				free (type);
 			    }
 			}
 			gotelem++;
 			break;
Index: ldapserver/ldap/servers/slapd/modify.c
===================================================================
RCS file: /cvs/dirsec/ldapserver/ldap/servers/slapd/modify.c,v
retrieving revision 1.8
diff -u -8 -r1.8 modify.c
--- ldapserver/ldap/servers/slapd/modify.c	25 Jan 2006 16:51:39 -0000	1.8
+++ ldapserver/ldap/servers/slapd/modify.c	27 Jan 2006 16:35:54 -0000
@@ -109,27 +109,27 @@
 };
 
 /* This function is called to process operation that come over external connections */
 void
 do_modify( Slapi_PBlock *pb )
 {
 	Slapi_Operation *operation;
 	BerElement			*ber;
-	char				*last, *type;
+	char				*last, *type = NULL;
 	unsigned long		tag, len;
 	LDAPMod				*mod;
 	LDAPMod			    **mods;
 	Slapi_Mods			smods;
 	int					err;
 	int					pw_change = 0; 	/* 0= no password change */
 	int					ignored_some_mods = 0;
 	int                 has_password_mod = 0; /* number of password mods */
 	char				*old_pw = NULL;	/* remember the old password */
-	char				*dn;
+	char				*dn = NULL;
 
 	LDAPDebug( LDAP_DEBUG_TRACE, "do_modify\n", 0, 0, 0 );
 
 	slapi_pblock_get( pb, SLAPI_OPERATION, &operation);
 	ber = operation->o_ber;
 
 	/* count the modify request */
 	PR_AtomicIncrement(g_get_global_snmp_vars()->ops_tbl.dsModifyEntryOps);
@@ -156,16 +156,17 @@
     {
     	if ( ber_scanf( ber, "{a", &dn ) == LBER_ERROR )
     	{
     		LDAPDebug( LDAP_DEBUG_ANY,
     		    "ber_scanf failed (op=Modify; params=DN)\n", 0, 0, 0 );
 			op_shared_log_error_access (pb, "MOD", "???", "decoding error");
     		send_ldap_result( pb, LDAP_PROTOCOL_ERROR, NULL, NULL, 0,
     		    NULL );
+    		slapi_ch_free_string(&dn);
     		return;
     	}
 	}
 
 	LDAPDebug( LDAP_DEBUG_ARGS, "do_modify: dn (%s)\n", dn, 0, 0 );
 
 	slapi_pblock_set( pb, SLAPI_REQUESTOR_ISROOT, &pb->pb_op->o_isroot);
 	slapi_pblock_set( pb, SLAPI_ORIGINAL_TARGET, dn ); 
@@ -181,17 +182,19 @@
 		mod->mod_bvalues = NULL;
 
 		if ( ber_scanf( ber, "{i{a[V]}}", &long_mod_op, &type,
 		    &mod->mod_bvalues ) == LBER_ERROR )
 		{
 			op_shared_log_error_access (pb, "MOD", dn, "decoding error");
 			send_ldap_result( pb, LDAP_PROTOCOL_ERROR, NULL,
 							  "decoding error", 0, NULL );
+			ber_bvecfree(mod->mod_bvalues);
 			slapi_ch_free((void **)&mod);
+			slapi_ch_free_string(&type);
 			goto free_and_return;
 		}
 		mod->mod_op = long_mod_op;
 		mod->mod_type = slapi_attr_syntax_normalize(type);
 		if ( !mod->mod_type || !*mod->mod_type ) {
 			char ebuf[BUFSIZ];
 			PR_snprintf (ebuf, BUFSIZ, "invalid type '%s'", type);
 			op_shared_log_error_access (pb, "MOD", dn, ebuf);
Index: ldapserver/ldap/servers/slapd/modrdn.c
===================================================================
RCS file: /cvs/dirsec/ldapserver/ldap/servers/slapd/modrdn.c,v
retrieving revision 1.4
diff -u -8 -r1.4 modrdn.c
--- ldapserver/ldap/servers/slapd/modrdn.c	19 Apr 2005 22:07:36 -0000	1.4
+++ ldapserver/ldap/servers/slapd/modrdn.c	27 Jan 2006 16:35:54 -0000
@@ -61,20 +61,20 @@
 static void op_shared_rename (Slapi_PBlock *pb, int passin_args );
 
 /* This function is called to process operation that come over external connections */
 void
 do_modrdn( Slapi_PBlock *pb )
 {
 	Slapi_Operation *operation;
 	BerElement	*ber;
-	char		*dn, *newsuperior = NULL;
+	char		*dn = NULL, *newsuperior = NULL;
 	char        *newrdn = NULL;
-	int			err, deloldrdn;
-	unsigned long	len;
+	int			err = 0, deloldrdn = 0;
+	unsigned long	len = 0;
 
 	LDAPDebug( LDAP_DEBUG_TRACE, "do_modrdn\n", 0, 0, 0 );
 
 	/* count the modrdn request */
 	PR_AtomicIncrement(g_get_global_snmp_vars()->ops_tbl.dsModifyRDNOps);
 
 	slapi_pblock_get( pb, SLAPI_OPERATION, &operation);
 	ber = operation->o_ber;
@@ -94,17 +94,17 @@
 	    == LBER_ERROR ) {
 		LDAPDebug( LDAP_DEBUG_ANY,
 		    "ber_scanf failed (op=ModRDN; params=DN,newRDN,deleteOldRDN)\n",
 		    0, 0, 0 );
 		op_shared_log_error_access (pb, "MODRDN", "???", "decoding error");
 		send_ldap_result( pb, LDAP_PROTOCOL_ERROR, NULL,
 		    "unable to decode DN, newRDN, or deleteOldRDN parameters",
 		    0, NULL );
-		return;
+        goto free_and_return;
 	}
 
 	if ( ber_peek_tag( ber, &len ) == LDAP_TAG_NEWSUPERIOR ) {
 		if ( pb->pb_conn->c_ldapversion < LDAP_VERSION3 ) {
 			LDAPDebug( LDAP_DEBUG_ANY,
 			    "got newSuperior in LDAPv2 modrdn op\n", 0, 0, 0 );
 			op_shared_log_error_access (pb, "MODRDN", dn, "decoding error");
 			send_ldap_result( pb, LDAP_PROTOCOL_ERROR, NULL,
Index: ldapserver/ldap/servers/slapd/passwd_extop.c
===================================================================
RCS file: /cvs/dirsec/ldapserver/ldap/servers/slapd/passwd_extop.c,v
retrieving revision 1.6
diff -u -8 -r1.6 passwd_extop.c
--- ldapserver/ldap/servers/slapd/passwd_extop.c	19 Apr 2005 22:07:36 -0000	1.6
+++ ldapserver/ldap/servers/slapd/passwd_extop.c	27 Jan 2006 16:35:54 -0000
@@ -292,32 +292,34 @@
 	}
 
 	
 	/* identify userID field by tags */
 	if (tag == LDAP_EXTOP_PASSMOD_TAG_USERID )
 	{
 		if ( ber_scanf( ber, "a", &dn) == LBER_ERROR )
     		{
+    		slapi_ch_free_string(&dn);
     		LDAPDebug( LDAP_DEBUG_ANY,
     		    "ber_scanf failed :{\n", 0, 0, 0 );
     		errMesg = "ber_scanf failed at userID parse.\n";
 		rc = LDAP_PROTOCOL_ERROR;
 		goto free_and_return;
     		}
 		
 		tag = ber_peek_tag( ber, &len);
 	} 
 	
 	
 	/* identify oldPasswd field by tags */
 	if (tag == LDAP_EXTOP_PASSMOD_TAG_OLDPWD )
 	{
 		if ( ber_scanf( ber, "a", &oldPasswd ) == LBER_ERROR )
     		{
+    		slapi_ch_free_string(&oldPasswd);
     		LDAPDebug( LDAP_DEBUG_ANY,
     		    "ber_scanf failed :{\n", 0, 0, 0 );
     		errMesg = "ber_scanf failed at oldPasswd parse.\n";
 		rc = LDAP_PROTOCOL_ERROR;
 		goto free_and_return;
     		}
 		tag = ber_peek_tag( ber, &len);
 	} else {
@@ -326,16 +328,17 @@
 		goto free_and_return;
 	}
 	
 	/* identify newPasswd field by tags */
 	if (tag ==  LDAP_EXTOP_PASSMOD_TAG_NEWPWD )
 	{
 		if ( ber_scanf( ber, "a", &newPasswd ) == LBER_ERROR )
     		{
+    		slapi_ch_free_string(&newPasswd);
     		LDAPDebug( LDAP_DEBUG_ANY,
     		    "ber_scanf failed :{\n", 0, 0, 0 );
     		errMesg = "ber_scanf failed at newPasswd parse.\n";
 		rc = LDAP_PROTOCOL_ERROR;
 		goto free_and_return;
     		}
 	} else {
 		errMesg = "New passwd must be supplied by the user.\n";
Index: ldapserver/ldap/servers/slapd/back-ldbm/sort.c
===================================================================
RCS file: /cvs/dirsec/ldapserver/ldap/servers/slapd/back-ldbm/sort.c,v
retrieving revision 1.5
diff -u -8 -r1.5 sort.c
--- ldapserver/ldap/servers/slapd/back-ldbm/sort.c	19 Apr 2005 22:07:38 -0000	1.5
+++ ldapserver/ldap/servers/slapd/back-ldbm/sort.c	27 Jan 2006 16:35:55 -0000
@@ -379,16 +379,17 @@
     	unsigned long return_value;
 
 		next_tag = ber_first_element( ber, &len, &inner_last );
 
 		/* The type is not optional */
 
 		return_value = ber_scanf(ber,"a",&rtype);
 		if (LBER_ERROR == return_value) {
+			slapi_ch_free_string(&rtype);
 			rc = LDAP_PROTOCOL_ERROR;
                         goto err;
 		}
 		/* normalize */
 		type = slapi_attr_syntax_normalize(rtype);
 		free(rtype);
 
 		/* Now look for the next tag. */
