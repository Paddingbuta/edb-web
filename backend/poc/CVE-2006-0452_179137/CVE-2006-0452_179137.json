{
    "bugid": "179137",
    "cveid": [
        "CVE-2006-0452"
    ],
    "summary": "CVE-2006-0452 recursion causes OOM with bad DN in dn2ancestor",
    "alias": "CVE-2006-0452",
    "product": "Security Response",
    "hardware": "All",
    "os": "Linux",
    "url": "",
    "reported_date": "2006-01-27 17:01 UTC byRich Megginson",
    "attachment": [
        "https://bugzilla-attachments.redhat.com/attachment.cgi?id=123785",
        "https://bugzilla-attachments.redhat.com/attachment.cgi?id=123786"
    ],
    "comment": [
        "If you perform a ModDN operation with a DN consisting of nothing but 100,000 ','\ncharacters (a very badly formed DN, to be sure), the dn2ancestor code will\nhappily traverse back through the entire DN one comma at a time looking for an\nexisting parent of the entry using dn2entry.  What's worse, it uses recursion to\ndo so (dn2ancestor -> dn2ancestor_or_entry -> dn2ancestor -> etc.), chewing up\nCPU and finally all of the RAM causing an OOM exit.",
        "Createdattachment 123785[details]files for fix",
        "Createdattachment 123786[details]diffs for fix",
        "Note of CVE name:\n\n        CVE-2006-0452: A carefully crafted malformed DN will cause the\n        server to recurse until it runs out of memory and exits",
        "Reviewed by: All (Thanks!)\nFiles:https://bugzilla.redhat.com/bugzilla/attachment.cgi?id=123785Branch: HEAD\nFix Description:https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=179137#c0The fix looks scary, but I thought it would be best to get rid of \nrecursion entirely (ugh - recursion in a multi threaded server - this \nisn't lisp . . .).  Along with eliminating recursion, I created a new \nfunction called slapi_dn_find_parent that just returns a pointer to the \nbeginning of the parent of the given dn, rather than returning a copy \n(as in slapi_dn_parent), to eliminate malloc/free in cases where it is \nunnecessary such as iterating through the parents in an DN.  The new \nfunction is basically just the guts of slapi_dn_parent with one twist, \nspecifically to address the bug in question - it skips through \nconsecutive runs of DN separator characters.  We should probably have a \nfunction like const char *slapi_dn_is_valid(const char *) that returns \nNULL if the given DN is valid or returns a pointer to the first invalid \ncharacter if not.  We could probably save a lot of time in processing \nbad or malicious client requests.\n\nAnyway, back to dn2ancestor.  The given ancestordn must contain the \n_unnormalized_ parent DN, since some clients get irritated when they get \nback an DN in a different form than given.  However, we need to have a \nnormalized DN to pass to dn2entry, and we cannot use a single Slapi_DN \nthat has both a dn and a ndn that are passed in byval (unless we add a \nnew API or skip the API altogether), so the variable ancestorndn holds \nthe normalized DN.  Using the original pointer to the given sdn also \nallows us to avoid malloc/free entirely.\nPlatforms tested: Fedora Core 4\nFlag Day: no\nDoc impact: no\nQA impact: should be covered by regular nightly and manual testing\nNew Tests integrated into TET: We need a test case that calls moddn and \nmodify operations with really bad DNs, consisting of nothing but \nthousands of ',', '+', and '=' chars.\n\nChecking in ldapserver/ldap/servers/slapd/dn.c;\n/cvs/dirsec/ldapserver/ldap/servers/slapd/dn.c,v  <--  dn.c\nnew revision: 1.8; previous revision: 1.7\ndone\nChecking in ldapserver/ldap/servers/slapd/slapi-plugin.h;\n/cvs/dirsec/ldapserver/ldap/servers/slapd/slapi-plugin.h,v  <--  slapi-plugin.h\nnew revision: 1.9; previous revision: 1.8\ndone\nChecking in ldapserver/ldap/servers/slapd/back-ldbm/dn2entry.c;\n/cvs/dirsec/ldapserver/ldap/servers/slapd/back-ldbm/dn2entry.c,v  <--  dn2entry.c\nnew revision: 1.5; previous revision: 1.4\ndone",
        "Verified DS 6.21 SP3 20060310.1",
        "Somehow the errata system did not automatically close these bugs even though DS\nSP 2 is shipped and available live on RHN",
        "trying to manually close",
        "trying again"
    ]
}